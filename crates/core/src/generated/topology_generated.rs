// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod topology {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_PEER_CHANGE_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_PEER_CHANGE_TYPE: u8 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_PEER_CHANGE_TYPE: [PeerChangeType; 4] = [
        PeerChangeType::NONE,
        PeerChangeType::AddedConnection,
        PeerChangeType::RemovedConnection,
        PeerChangeType::Error,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct PeerChangeType(pub u8);
    #[allow(non_upper_case_globals)]
    impl PeerChangeType {
        pub const NONE: Self = Self(0);
        pub const AddedConnection: Self = Self(1);
        pub const RemovedConnection: Self = Self(2);
        pub const Error: Self = Self(3);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::AddedConnection,
            Self::RemovedConnection,
            Self::Error,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::AddedConnection => Some("AddedConnection"),
                Self::RemovedConnection => Some("RemovedConnection"),
                Self::Error => Some("Error"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for PeerChangeType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for PeerChangeType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for PeerChangeType {
        type Output = PeerChangeType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for PeerChangeType {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for PeerChangeType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for PeerChangeType {}
    pub struct PeerChangeTypeUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_RESPONSE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_RESPONSE: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_RESPONSE: [Response; 3] = [Response::NONE, Response::Error, Response::Ok];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Response(pub u8);
    #[allow(non_upper_case_globals)]
    impl Response {
        pub const NONE: Self = Self(0);
        pub const Error: Self = Self(1);
        pub const Ok: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::Error, Self::Ok];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Error => Some("Error"),
                Self::Ok => Some("Ok"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for Response {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Response {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for Response {
        type Output = Response;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for Response {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Response {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Response {}
    pub struct ResponseUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_CONTRACT_CHANGE_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_CONTRACT_CHANGE_TYPE: u8 = 10;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_CONTRACT_CHANGE_TYPE: [ContractChangeType; 11] = [
        ContractChangeType::NONE,
        ContractChangeType::PutRequest,
        ContractChangeType::PutSuccess,
        ContractChangeType::PutFailure,
        ContractChangeType::BroadcastEmitted,
        ContractChangeType::BroadcastReceived,
        ContractChangeType::UpdateRequest,
        ContractChangeType::UpdateSuccess,
        ContractChangeType::UpdateFailure,
        ContractChangeType::GetContract,
        ContractChangeType::SubscribedToContract,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ContractChangeType(pub u8);
    #[allow(non_upper_case_globals)]
    impl ContractChangeType {
        pub const NONE: Self = Self(0);
        pub const PutRequest: Self = Self(1);
        pub const PutSuccess: Self = Self(2);
        pub const PutFailure: Self = Self(3);
        pub const BroadcastEmitted: Self = Self(4);
        pub const BroadcastReceived: Self = Self(5);
        pub const UpdateRequest: Self = Self(6);
        pub const UpdateSuccess: Self = Self(7);
        pub const UpdateFailure: Self = Self(8);
        pub const GetContract: Self = Self(9);
        pub const SubscribedToContract: Self = Self(10);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 10;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::PutRequest,
            Self::PutSuccess,
            Self::PutFailure,
            Self::BroadcastEmitted,
            Self::BroadcastReceived,
            Self::UpdateRequest,
            Self::UpdateSuccess,
            Self::UpdateFailure,
            Self::GetContract,
            Self::SubscribedToContract,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::PutRequest => Some("PutRequest"),
                Self::PutSuccess => Some("PutSuccess"),
                Self::PutFailure => Some("PutFailure"),
                Self::BroadcastEmitted => Some("BroadcastEmitted"),
                Self::BroadcastReceived => Some("BroadcastReceived"),
                Self::UpdateRequest => Some("UpdateRequest"),
                Self::UpdateSuccess => Some("UpdateSuccess"),
                Self::UpdateFailure => Some("UpdateFailure"),
                Self::GetContract => Some("GetContract"),
                Self::SubscribedToContract => Some("SubscribedToContract"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ContractChangeType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ContractChangeType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ContractChangeType {
        type Output = ContractChangeType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ContractChangeType {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ContractChangeType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ContractChangeType {}
    pub struct ContractChangeTypeUnionTableOffset {}

    pub enum AddedConnectionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AddedConnection<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AddedConnection<'a> {
        type Inner = AddedConnection<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AddedConnection<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_FROM: flatbuffers::VOffsetT = 6;
        pub const VT_FROM_LOCATION: flatbuffers::VOffsetT = 8;
        pub const VT_TO: flatbuffers::VOffsetT = 10;
        pub const VT_TO_LOCATION: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AddedConnection { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AddedConnectionArgs<'args>,
        ) -> flatbuffers::WIPOffset<AddedConnection<'bldr>> {
            let mut builder = AddedConnectionBuilder::new(_fbb);
            builder.add_to_location(args.to_location);
            builder.add_from_location(args.from_location);
            if let Some(x) = args.to {
                builder.add_to(x);
            }
            if let Some(x) = args.from {
                builder.add_from(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    AddedConnection::VT_TRANSACTION,
                    None,
                )
            }
        }
        #[inline]
        pub fn from(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        AddedConnection::VT_FROM,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn from_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(AddedConnection::VT_FROM_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn to(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        AddedConnection::VT_TO,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn to_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(AddedConnection::VT_TO_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AddedConnection<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "from",
                    Self::VT_FROM,
                    true,
                )?
                .visit_field::<f64>("from_location", Self::VT_FROM_LOCATION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "to",
                    Self::VT_TO,
                    true,
                )?
                .visit_field::<f64>("to_location", Self::VT_TO_LOCATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AddedConnectionArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub from: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub from_location: f64,
        pub to: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub to_location: f64,
    }
    impl<'a> Default for AddedConnectionArgs<'a> {
        #[inline]
        fn default() -> Self {
            AddedConnectionArgs {
                transaction: None,
                from: None, // required field
                from_location: 0.0,
                to: None, // required field
                to_location: 0.0,
            }
        }
    }

    pub struct AddedConnectionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AddedConnectionBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AddedConnection::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_from(&mut self, from: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AddedConnection::VT_FROM, from);
        }
        #[inline]
        pub fn add_from_location(&mut self, from_location: f64) {
            self.fbb_
                .push_slot::<f64>(AddedConnection::VT_FROM_LOCATION, from_location, 0.0);
        }
        #[inline]
        pub fn add_to(&mut self, to: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AddedConnection::VT_TO, to);
        }
        #[inline]
        pub fn add_to_location(&mut self, to_location: f64) {
            self.fbb_
                .push_slot::<f64>(AddedConnection::VT_TO_LOCATION, to_location, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AddedConnectionBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AddedConnectionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AddedConnection<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, AddedConnection::VT_FROM, "from");
            self.fbb_.required(o, AddedConnection::VT_TO, "to");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AddedConnection<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AddedConnection");
            ds.field("transaction", &self.transaction());
            ds.field("from", &self.from());
            ds.field("from_location", &self.from_location());
            ds.field("to", &self.to());
            ds.field("to_location", &self.to_location());
            ds.finish()
        }
    }
    pub enum RemovedConnectionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RemovedConnection<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RemovedConnection<'a> {
        type Inner = RemovedConnection<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RemovedConnection<'a> {
        pub const VT_AT: flatbuffers::VOffsetT = 4;
        pub const VT_FROM: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RemovedConnection { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RemovedConnectionArgs<'args>,
        ) -> flatbuffers::WIPOffset<RemovedConnection<'bldr>> {
            let mut builder = RemovedConnectionBuilder::new(_fbb);
            if let Some(x) = args.from {
                builder.add_from(x);
            }
            if let Some(x) = args.at {
                builder.add_at(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn at(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        RemovedConnection::VT_AT,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn from(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        RemovedConnection::VT_FROM,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for RemovedConnection<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "at",
                    Self::VT_AT,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "from",
                    Self::VT_FROM,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RemovedConnectionArgs<'a> {
        pub at: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub from: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for RemovedConnectionArgs<'a> {
        #[inline]
        fn default() -> Self {
            RemovedConnectionArgs {
                at: None,   // required field
                from: None, // required field
            }
        }
    }

    pub struct RemovedConnectionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RemovedConnectionBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_at(&mut self, at: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RemovedConnection::VT_AT, at);
        }
        #[inline]
        pub fn add_from(&mut self, from: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RemovedConnection::VT_FROM, from);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RemovedConnectionBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RemovedConnectionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RemovedConnection<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, RemovedConnection::VT_AT, "at");
            self.fbb_.required(o, RemovedConnection::VT_FROM, "from");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RemovedConnection<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RemovedConnection");
            ds.field("at", &self.at());
            ds.field("from", &self.from());
            ds.finish()
        }
    }
    pub enum ErrorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Error<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Error<'a> {
        type Inner = Error<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Error<'a> {
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Error { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ErrorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Error<'bldr>> {
            let mut builder = ErrorBuilder::new(_fbb);
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn message(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_MESSAGE, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Error<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "message",
                    Self::VT_MESSAGE,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ErrorArgs<'a> {
        pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ErrorArgs<'a> {
        #[inline]
        fn default() -> Self {
            ErrorArgs {
                message: None, // required field
            }
        }
    }

    pub struct ErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_MESSAGE, message);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ErrorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Error::VT_MESSAGE, "message");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Error<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Error");
            ds.field("message", &self.message());
            ds.finish()
        }
    }
    pub enum PeerChangeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PeerChange<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PeerChange<'a> {
        type Inner = PeerChange<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PeerChange<'a> {
        pub const VT_CURRENT_STATE: flatbuffers::VOffsetT = 4;
        pub const VT_CHANGE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_CHANGE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PeerChange { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PeerChangeArgs<'args>,
        ) -> flatbuffers::WIPOffset<PeerChange<'bldr>> {
            let mut builder = PeerChangeBuilder::new(_fbb);
            if let Some(x) = args.change {
                builder.add_change(x);
            }
            if let Some(x) = args.current_state {
                builder.add_current_state(x);
            }
            builder.add_change_type(args.change_type);
            builder.finish()
        }

        #[inline]
        pub fn current_state(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddedConnection<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddedConnection>>,
                >>(PeerChange::VT_CURRENT_STATE, None)
            }
        }
        #[inline]
        pub fn change_type(&self) -> PeerChangeType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<PeerChangeType>(PeerChange::VT_CHANGE_TYPE, Some(PeerChangeType::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn change(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        PeerChange::VT_CHANGE,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_added_connection(&self) -> Option<AddedConnection<'a>> {
            if self.change_type() == PeerChangeType::AddedConnection {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { AddedConnection::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_removed_connection(&self) -> Option<RemovedConnection<'a>> {
            if self.change_type() == PeerChangeType::RemovedConnection {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { RemovedConnection::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_error(&self) -> Option<Error<'a>> {
            if self.change_type() == PeerChangeType::Error {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Error::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for PeerChange<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AddedConnection>>>>("current_state", Self::VT_CURRENT_STATE, false)?
     .visit_union::<PeerChangeType, _>("change_type", Self::VT_CHANGE_TYPE, "change", Self::VT_CHANGE, false, |key, v, pos| {
        match key {
          PeerChangeType::AddedConnection => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddedConnection>>("PeerChangeType::AddedConnection", pos),
          PeerChangeType::RemovedConnection => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RemovedConnection>>("PeerChangeType::RemovedConnection", pos),
          PeerChangeType::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>("PeerChangeType::Error", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct PeerChangeArgs<'a> {
        pub current_state: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddedConnection<'a>>>,
            >,
        >,
        pub change_type: PeerChangeType,
        pub change: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PeerChangeArgs<'a> {
        #[inline]
        fn default() -> Self {
            PeerChangeArgs {
                current_state: None,
                change_type: PeerChangeType::NONE,
                change: None,
            }
        }
    }

    pub struct PeerChangeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PeerChangeBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_current_state(
            &mut self,
            current_state: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AddedConnection<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PeerChange::VT_CURRENT_STATE,
                current_state,
            );
        }
        #[inline]
        pub fn add_change_type(&mut self, change_type: PeerChangeType) {
            self.fbb_.push_slot::<PeerChangeType>(
                PeerChange::VT_CHANGE_TYPE,
                change_type,
                PeerChangeType::NONE,
            );
        }
        #[inline]
        pub fn add_change(&mut self, change: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PeerChange::VT_CHANGE, change);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PeerChangeBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PeerChangeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PeerChange<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PeerChange<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PeerChange");
            ds.field("current_state", &self.current_state());
            ds.field("change_type", &self.change_type());
            match self.change_type() {
                PeerChangeType::AddedConnection => {
                    if let Some(x) = self.change_as_added_connection() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                PeerChangeType::RemovedConnection => {
                    if let Some(x) = self.change_as_removed_connection() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                PeerChangeType::Error => {
                    if let Some(x) = self.change_as_error() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("change", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum OkOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Ok<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Ok<'a> {
        type Inner = Ok<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Ok<'a> {
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Ok { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args OkArgs<'args>,
        ) -> flatbuffers::WIPOffset<Ok<'bldr>> {
            let mut builder = OkBuilder::new(_fbb);
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn message(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Ok::VT_MESSAGE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Ok<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "message",
                    Self::VT_MESSAGE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct OkArgs<'a> {
        pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for OkArgs<'a> {
        #[inline]
        fn default() -> Self {
            OkArgs { message: None }
        }
    }

    pub struct OkBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OkBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Ok::VT_MESSAGE, message);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OkBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            OkBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Ok<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Ok<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Ok");
            ds.field("message", &self.message());
            ds.finish()
        }
    }
    pub enum ControllerResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ControllerResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ControllerResponse<'a> {
        type Inner = ControllerResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ControllerResponse<'a> {
        pub const VT_RESPONSE_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_RESPONSE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ControllerResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ControllerResponseArgs,
        ) -> flatbuffers::WIPOffset<ControllerResponse<'bldr>> {
            let mut builder = ControllerResponseBuilder::new(_fbb);
            if let Some(x) = args.response {
                builder.add_response(x);
            }
            builder.add_response_type(args.response_type);
            builder.finish()
        }

        #[inline]
        pub fn response_type(&self) -> Response {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Response>(ControllerResponse::VT_RESPONSE_TYPE, Some(Response::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn response(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        ControllerResponse::VT_RESPONSE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn response_as_error(&self) -> Option<Error<'a>> {
            if self.response_type() == Response::Error {
                let u = self.response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { Error::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn response_as_ok(&self) -> Option<Ok<'a>> {
            if self.response_type() == Response::Ok {
                let u = self.response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { Ok::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ControllerResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<Response, _>(
                    "response_type",
                    Self::VT_RESPONSE_TYPE,
                    "response",
                    Self::VT_RESPONSE,
                    true,
                    |key, v, pos| match key {
                        Response::Error => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>(
                                "Response::Error",
                                pos,
                            ),
                        Response::Ok => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Ok>>(
                            "Response::Ok",
                            pos,
                        ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ControllerResponseArgs {
        pub response_type: Response,
        pub response: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ControllerResponseArgs {
        #[inline]
        fn default() -> Self {
            ControllerResponseArgs {
                response_type: Response::NONE,
                response: None, // required field
            }
        }
    }

    pub struct ControllerResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ControllerResponseBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_response_type(&mut self, response_type: Response) {
            self.fbb_.push_slot::<Response>(
                ControllerResponse::VT_RESPONSE_TYPE,
                response_type,
                Response::NONE,
            );
        }
        #[inline]
        pub fn add_response(
            &mut self,
            response: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ControllerResponse::VT_RESPONSE,
                response,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ControllerResponseBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ControllerResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ControllerResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, ControllerResponse::VT_RESPONSE, "response");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ControllerResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ControllerResponse");
            ds.field("response_type", &self.response_type());
            match self.response_type() {
                Response::Error => {
                    if let Some(x) = self.response_as_error() {
                        ds.field("response", &x)
                    } else {
                        ds.field(
                            "response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Response::Ok => {
                    if let Some(x) = self.response_as_ok() {
                        ds.field("response", &x)
                    } else {
                        ds.field(
                            "response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("response", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum PutRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PutRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PutRequest<'a> {
        type Inner = PutRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PutRequest<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_KEY: flatbuffers::VOffsetT = 6;
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 8;
        pub const VT_TARGET: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PutRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PutRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<PutRequest<'bldr>> {
            let mut builder = PutRequestBuilder::new(_fbb);
            builder.add_contract_location(args.contract_location);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutRequest::VT_TRANSACTION, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutRequest::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutRequest::VT_REQUESTER, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutRequest::VT_TARGET, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(PutRequest::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(PutRequest::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for PutRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PutRequestArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub target: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u64,
        pub contract_location: f64,
    }
    impl<'a> Default for PutRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            PutRequestArgs {
                transaction: None, // required field
                key: None,         // required field
                requester: None,   // required field
                target: None,      // required field
                timestamp: 0,
                contract_location: 0.0,
            }
        }
    }

    pub struct PutRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PutRequestBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PutRequest::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutRequest::VT_KEY, key);
        }
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutRequest::VT_REQUESTER, requester);
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutRequest::VT_TARGET, target);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(PutRequest::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_
                .push_slot::<f64>(PutRequest::VT_CONTRACT_LOCATION, contract_location, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PutRequestBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PutRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PutRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, PutRequest::VT_TRANSACTION, "transaction");
            self.fbb_.required(o, PutRequest::VT_KEY, "key");
            self.fbb_.required(o, PutRequest::VT_REQUESTER, "requester");
            self.fbb_.required(o, PutRequest::VT_TARGET, "target");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PutRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PutRequest");
            ds.field("transaction", &self.transaction());
            ds.field("key", &self.key());
            ds.field("requester", &self.requester());
            ds.field("target", &self.target());
            ds.field("timestamp", &self.timestamp());
            ds.field("contract_location", &self.contract_location());
            ds.finish()
        }
    }
    pub enum UpdateRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdateRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdateRequest<'a> {
        type Inner = UpdateRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UpdateRequest<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_KEY: flatbuffers::VOffsetT = 6;
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 8;
        pub const VT_TARGET: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdateRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdateRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdateRequest<'bldr>> {
            let mut builder = UpdateRequestBuilder::new(_fbb);
            builder.add_contract_location(args.contract_location);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateRequest::VT_TRANSACTION, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateRequest::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateRequest::VT_REQUESTER, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateRequest::VT_TARGET, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(UpdateRequest::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(UpdateRequest::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UpdateRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdateRequestArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub target: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u64,
        pub contract_location: f64,
    }
    impl<'a> Default for UpdateRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdateRequestArgs {
                transaction: None, // required field
                key: None,         // required field
                requester: None,   // required field
                target: None,      // required field
                timestamp: 0,
                contract_location: 0.0,
            }
        }
    }

    pub struct UpdateRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdateRequestBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UpdateRequest::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateRequest::VT_KEY, key);
        }
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UpdateRequest::VT_REQUESTER,
                requester,
            );
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateRequest::VT_TARGET, target);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(UpdateRequest::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_
                .push_slot::<f64>(UpdateRequest::VT_CONTRACT_LOCATION, contract_location, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdateRequestBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdateRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdateRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, UpdateRequest::VT_TRANSACTION, "transaction");
            self.fbb_.required(o, UpdateRequest::VT_KEY, "key");
            self.fbb_
                .required(o, UpdateRequest::VT_REQUESTER, "requester");
            self.fbb_.required(o, UpdateRequest::VT_TARGET, "target");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdateRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdateRequest");
            ds.field("transaction", &self.transaction());
            ds.field("key", &self.key());
            ds.field("requester", &self.requester());
            ds.field("target", &self.target());
            ds.field("timestamp", &self.timestamp());
            ds.field("contract_location", &self.contract_location());
            ds.finish()
        }
    }
    pub enum PutSuccessOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PutSuccess<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PutSuccess<'a> {
        type Inner = PutSuccess<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PutSuccess<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 6;
        pub const VT_TARGET: flatbuffers::VOffsetT = 8;
        pub const VT_KEY: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PutSuccess { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PutSuccessArgs<'args>,
        ) -> flatbuffers::WIPOffset<PutSuccess<'bldr>> {
            let mut builder = PutSuccessBuilder::new(_fbb);
            builder.add_contract_location(args.contract_location);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutSuccess::VT_TRANSACTION, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutSuccess::VT_REQUESTER, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutSuccess::VT_TARGET, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutSuccess::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(PutSuccess::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(PutSuccess::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for PutSuccess<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PutSuccessArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub target: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u64,
        pub contract_location: f64,
    }
    impl<'a> Default for PutSuccessArgs<'a> {
        #[inline]
        fn default() -> Self {
            PutSuccessArgs {
                transaction: None, // required field
                requester: None,   // required field
                target: None,      // required field
                key: None,         // required field
                timestamp: 0,
                contract_location: 0.0,
            }
        }
    }

    pub struct PutSuccessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PutSuccessBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PutSuccess::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutSuccess::VT_REQUESTER, requester);
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutSuccess::VT_TARGET, target);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutSuccess::VT_KEY, key);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(PutSuccess::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_
                .push_slot::<f64>(PutSuccess::VT_CONTRACT_LOCATION, contract_location, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PutSuccessBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PutSuccessBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PutSuccess<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, PutSuccess::VT_TRANSACTION, "transaction");
            self.fbb_.required(o, PutSuccess::VT_REQUESTER, "requester");
            self.fbb_.required(o, PutSuccess::VT_TARGET, "target");
            self.fbb_.required(o, PutSuccess::VT_KEY, "key");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PutSuccess<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PutSuccess");
            ds.field("transaction", &self.transaction());
            ds.field("requester", &self.requester());
            ds.field("target", &self.target());
            ds.field("key", &self.key());
            ds.field("timestamp", &self.timestamp());
            ds.field("contract_location", &self.contract_location());
            ds.finish()
        }
    }
    pub enum PutFailureOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PutFailure<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PutFailure<'a> {
        type Inner = PutFailure<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PutFailure<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 6;
        pub const VT_TARGET: flatbuffers::VOffsetT = 8;
        pub const VT_KEY: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PutFailure { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PutFailureArgs<'args>,
        ) -> flatbuffers::WIPOffset<PutFailure<'bldr>> {
            let mut builder = PutFailureBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutFailure::VT_TRANSACTION, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutFailure::VT_REQUESTER, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutFailure::VT_TARGET, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PutFailure::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(PutFailure::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for PutFailure<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PutFailureArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub target: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u64,
    }
    impl<'a> Default for PutFailureArgs<'a> {
        #[inline]
        fn default() -> Self {
            PutFailureArgs {
                transaction: None, // required field
                requester: None,   // required field
                target: None,      // required field
                key: None,         // required field
                timestamp: 0,
            }
        }
    }

    pub struct PutFailureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PutFailureBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PutFailure::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutFailure::VT_REQUESTER, requester);
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutFailure::VT_TARGET, target);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PutFailure::VT_KEY, key);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(PutFailure::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PutFailureBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PutFailureBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PutFailure<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, PutFailure::VT_TRANSACTION, "transaction");
            self.fbb_.required(o, PutFailure::VT_REQUESTER, "requester");
            self.fbb_.required(o, PutFailure::VT_TARGET, "target");
            self.fbb_.required(o, PutFailure::VT_KEY, "key");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PutFailure<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PutFailure");
            ds.field("transaction", &self.transaction());
            ds.field("requester", &self.requester());
            ds.field("target", &self.target());
            ds.field("key", &self.key());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    pub enum UpdateSuccessOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdateSuccess<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdateSuccess<'a> {
        type Inner = UpdateSuccess<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UpdateSuccess<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 6;
        pub const VT_TARGET: flatbuffers::VOffsetT = 8;
        pub const VT_KEY: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdateSuccess { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdateSuccessArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdateSuccess<'bldr>> {
            let mut builder = UpdateSuccessBuilder::new(_fbb);
            builder.add_contract_location(args.contract_location);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateSuccess::VT_TRANSACTION, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateSuccess::VT_REQUESTER, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateSuccess::VT_TARGET, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateSuccess::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(UpdateSuccess::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(UpdateSuccess::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UpdateSuccess<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdateSuccessArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub target: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u64,
        pub contract_location: f64,
    }
    impl<'a> Default for UpdateSuccessArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdateSuccessArgs {
                transaction: None, // required field
                requester: None,   // required field
                target: None,      // required field
                key: None,         // required field
                timestamp: 0,
                contract_location: 0.0,
            }
        }
    }

    pub struct UpdateSuccessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdateSuccessBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UpdateSuccess::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UpdateSuccess::VT_REQUESTER,
                requester,
            );
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateSuccess::VT_TARGET, target);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateSuccess::VT_KEY, key);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(UpdateSuccess::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_
                .push_slot::<f64>(UpdateSuccess::VT_CONTRACT_LOCATION, contract_location, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdateSuccessBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdateSuccessBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdateSuccess<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, UpdateSuccess::VT_TRANSACTION, "transaction");
            self.fbb_
                .required(o, UpdateSuccess::VT_REQUESTER, "requester");
            self.fbb_.required(o, UpdateSuccess::VT_TARGET, "target");
            self.fbb_.required(o, UpdateSuccess::VT_KEY, "key");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdateSuccess<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdateSuccess");
            ds.field("transaction", &self.transaction());
            ds.field("requester", &self.requester());
            ds.field("target", &self.target());
            ds.field("key", &self.key());
            ds.field("timestamp", &self.timestamp());
            ds.field("contract_location", &self.contract_location());
            ds.finish()
        }
    }
    pub enum UpdateFailureOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdateFailure<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdateFailure<'a> {
        type Inner = UpdateFailure<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UpdateFailure<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 6;
        pub const VT_TARGET: flatbuffers::VOffsetT = 8;
        pub const VT_KEY: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdateFailure { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdateFailureArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdateFailure<'bldr>> {
            let mut builder = UpdateFailureBuilder::new(_fbb);
            builder.add_contract_location(args.contract_location);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateFailure::VT_TRANSACTION, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateFailure::VT_REQUESTER, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateFailure::VT_TARGET, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UpdateFailure::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(UpdateFailure::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(UpdateFailure::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UpdateFailure<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdateFailureArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub target: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u64,
        pub contract_location: f64,
    }
    impl<'a> Default for UpdateFailureArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdateFailureArgs {
                transaction: None, // required field
                requester: None,   // required field
                target: None,      // required field
                key: None,         // required field
                timestamp: 0,
                contract_location: 0.0,
            }
        }
    }

    pub struct UpdateFailureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdateFailureBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UpdateFailure::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UpdateFailure::VT_REQUESTER,
                requester,
            );
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateFailure::VT_TARGET, target);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateFailure::VT_KEY, key);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(UpdateFailure::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_
                .push_slot::<f64>(UpdateFailure::VT_CONTRACT_LOCATION, contract_location, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdateFailureBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdateFailureBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdateFailure<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, UpdateFailure::VT_TRANSACTION, "transaction");
            self.fbb_
                .required(o, UpdateFailure::VT_REQUESTER, "requester");
            self.fbb_.required(o, UpdateFailure::VT_TARGET, "target");
            self.fbb_.required(o, UpdateFailure::VT_KEY, "key");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdateFailure<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdateFailure");
            ds.field("transaction", &self.transaction());
            ds.field("requester", &self.requester());
            ds.field("target", &self.target());
            ds.field("key", &self.key());
            ds.field("timestamp", &self.timestamp());
            ds.field("contract_location", &self.contract_location());
            ds.finish()
        }
    }
    pub enum BroadcastEmittedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BroadcastEmitted<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BroadcastEmitted<'a> {
        type Inner = BroadcastEmitted<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BroadcastEmitted<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_UPSTREAM: flatbuffers::VOffsetT = 6;
        pub const VT_BROADCAST_TO: flatbuffers::VOffsetT = 8;
        pub const VT_BROADCASTED_TO: flatbuffers::VOffsetT = 10;
        pub const VT_KEY: flatbuffers::VOffsetT = 12;
        pub const VT_SENDER: flatbuffers::VOffsetT = 14;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 16;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BroadcastEmitted { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BroadcastEmittedArgs<'args>,
        ) -> flatbuffers::WIPOffset<BroadcastEmitted<'bldr>> {
            let mut builder = BroadcastEmittedBuilder::new(_fbb);
            builder.add_contract_location(args.contract_location);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.add_broadcasted_to(args.broadcasted_to);
            if let Some(x) = args.broadcast_to {
                builder.add_broadcast_to(x);
            }
            if let Some(x) = args.upstream {
                builder.add_upstream(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        BroadcastEmitted::VT_TRANSACTION,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn upstream(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastEmitted::VT_UPSTREAM, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn broadcast_to(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(BroadcastEmitted::VT_BROADCAST_TO, None)
            }
        }
        #[inline]
        pub fn broadcasted_to(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(BroadcastEmitted::VT_BROADCASTED_TO, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastEmitted::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn sender(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastEmitted::VT_SENDER, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(BroadcastEmitted::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(BroadcastEmitted::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BroadcastEmitted<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "upstream",
                    Self::VT_UPSTREAM,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("broadcast_to", Self::VT_BROADCAST_TO, false)?
                .visit_field::<u32>("broadcasted_to", Self::VT_BROADCASTED_TO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender", Self::VT_SENDER, true)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BroadcastEmittedArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub upstream: Option<flatbuffers::WIPOffset<&'a str>>,
        pub broadcast_to: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub broadcasted_to: u32,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u64,
        pub contract_location: f64,
    }
    impl<'a> Default for BroadcastEmittedArgs<'a> {
        #[inline]
        fn default() -> Self {
            BroadcastEmittedArgs {
                transaction: None, // required field
                upstream: None,    // required field
                broadcast_to: None,
                broadcasted_to: 0,
                key: None,    // required field
                sender: None, // required field
                timestamp: 0,
                contract_location: 0.0,
            }
        }
    }

    pub struct BroadcastEmittedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BroadcastEmittedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BroadcastEmitted::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_upstream(&mut self, upstream: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BroadcastEmitted::VT_UPSTREAM,
                upstream,
            );
        }
        #[inline]
        pub fn add_broadcast_to(
            &mut self,
            broadcast_to: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BroadcastEmitted::VT_BROADCAST_TO,
                broadcast_to,
            );
        }
        #[inline]
        pub fn add_broadcasted_to(&mut self, broadcasted_to: u32) {
            self.fbb_
                .push_slot::<u32>(BroadcastEmitted::VT_BROADCASTED_TO, broadcasted_to, 0);
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastEmitted::VT_KEY, key);
        }
        #[inline]
        pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastEmitted::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(BroadcastEmitted::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_.push_slot::<f64>(
                BroadcastEmitted::VT_CONTRACT_LOCATION,
                contract_location,
                0.0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BroadcastEmittedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BroadcastEmittedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BroadcastEmitted<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, BroadcastEmitted::VT_TRANSACTION, "transaction");
            self.fbb_
                .required(o, BroadcastEmitted::VT_UPSTREAM, "upstream");
            self.fbb_.required(o, BroadcastEmitted::VT_KEY, "key");
            self.fbb_.required(o, BroadcastEmitted::VT_SENDER, "sender");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BroadcastEmitted<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BroadcastEmitted");
            ds.field("transaction", &self.transaction());
            ds.field("upstream", &self.upstream());
            ds.field("broadcast_to", &self.broadcast_to());
            ds.field("broadcasted_to", &self.broadcasted_to());
            ds.field("key", &self.key());
            ds.field("sender", &self.sender());
            ds.field("timestamp", &self.timestamp());
            ds.field("contract_location", &self.contract_location());
            ds.finish()
        }
    }
    pub enum BroadcastReceivedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BroadcastReceived<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BroadcastReceived<'a> {
        type Inner = BroadcastReceived<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BroadcastReceived<'a> {
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
        pub const VT_TARGET: flatbuffers::VOffsetT = 6;
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 8;
        pub const VT_KEY: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BroadcastReceived { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BroadcastReceivedArgs<'args>,
        ) -> flatbuffers::WIPOffset<BroadcastReceived<'bldr>> {
            let mut builder = BroadcastReceivedBuilder::new(_fbb);
            builder.add_contract_location(args.contract_location);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        BroadcastReceived::VT_TRANSACTION,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastReceived::VT_TARGET, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        BroadcastReceived::VT_REQUESTER,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastReceived::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(BroadcastReceived::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(BroadcastReceived::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BroadcastReceived<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BroadcastReceivedArgs<'a> {
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub target: Option<flatbuffers::WIPOffset<&'a str>>,
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u64,
        pub contract_location: f64,
    }
    impl<'a> Default for BroadcastReceivedArgs<'a> {
        #[inline]
        fn default() -> Self {
            BroadcastReceivedArgs {
                transaction: None, // required field
                target: None,      // required field
                requester: None,   // required field
                key: None,         // required field
                timestamp: 0,
                contract_location: 0.0,
            }
        }
    }

    pub struct BroadcastReceivedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BroadcastReceivedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BroadcastReceived::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BroadcastReceived::VT_TARGET,
                target,
            );
        }
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BroadcastReceived::VT_REQUESTER,
                requester,
            );
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastReceived::VT_KEY, key);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(BroadcastReceived::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_.push_slot::<f64>(
                BroadcastReceived::VT_CONTRACT_LOCATION,
                contract_location,
                0.0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BroadcastReceivedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BroadcastReceivedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BroadcastReceived<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, BroadcastReceived::VT_TRANSACTION, "transaction");
            self.fbb_
                .required(o, BroadcastReceived::VT_TARGET, "target");
            self.fbb_
                .required(o, BroadcastReceived::VT_REQUESTER, "requester");
            self.fbb_.required(o, BroadcastReceived::VT_KEY, "key");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BroadcastReceived<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BroadcastReceived");
            ds.field("transaction", &self.transaction());
            ds.field("target", &self.target());
            ds.field("requester", &self.requester());
            ds.field("key", &self.key());
            ds.field("timestamp", &self.timestamp());
            ds.field("contract_location", &self.contract_location());
            ds.finish()
        }
    }
    pub enum GetContractOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GetContract<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GetContract<'a> {
        type Inner = GetContract<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GetContract<'a> {
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 4;
        pub const VT_TARGET: flatbuffers::VOffsetT = 6;
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 8;
        pub const VT_KEY: flatbuffers::VOffsetT = 10;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 12;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GetContract { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args GetContractArgs<'args>,
        ) -> flatbuffers::WIPOffset<GetContract<'bldr>> {
            let mut builder = GetContractBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            builder.add_contract_location(args.contract_location);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(GetContract::VT_REQUESTER, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(GetContract::VT_TARGET, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(GetContract::VT_TRANSACTION, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(GetContract::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(GetContract::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(GetContract::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for GetContract<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct GetContractArgs<'a> {
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub target: Option<flatbuffers::WIPOffset<&'a str>>,
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub contract_location: f64,
        pub timestamp: u64,
    }
    impl<'a> Default for GetContractArgs<'a> {
        #[inline]
        fn default() -> Self {
            GetContractArgs {
                requester: None,   // required field
                target: None,      // required field
                transaction: None, // required field
                key: None,         // required field
                contract_location: 0.0,
                timestamp: 0,
            }
        }
    }

    pub struct GetContractBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetContractBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                GetContract::VT_REQUESTER,
                requester,
            );
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(GetContract::VT_TARGET, target);
        }
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                GetContract::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(GetContract::VT_KEY, key);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_
                .push_slot::<f64>(GetContract::VT_CONTRACT_LOCATION, contract_location, 0.0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(GetContract::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> GetContractBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            GetContractBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GetContract<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, GetContract::VT_REQUESTER, "requester");
            self.fbb_.required(o, GetContract::VT_TARGET, "target");
            self.fbb_
                .required(o, GetContract::VT_TRANSACTION, "transaction");
            self.fbb_.required(o, GetContract::VT_KEY, "key");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GetContract<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GetContract");
            ds.field("requester", &self.requester());
            ds.field("target", &self.target());
            ds.field("transaction", &self.transaction());
            ds.field("key", &self.key());
            ds.field("contract_location", &self.contract_location());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    pub enum SubscribedToContractOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SubscribedToContract<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SubscribedToContract<'a> {
        type Inner = SubscribedToContract<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SubscribedToContract<'a> {
        pub const VT_REQUESTER: flatbuffers::VOffsetT = 4;
        pub const VT_TRANSACTION: flatbuffers::VOffsetT = 6;
        pub const VT_KEY: flatbuffers::VOffsetT = 8;
        pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 10;
        pub const VT_AT_PEER: flatbuffers::VOffsetT = 12;
        pub const VT_AT_PEER_LOCATION: flatbuffers::VOffsetT = 14;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SubscribedToContract { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SubscribedToContractArgs<'args>,
        ) -> flatbuffers::WIPOffset<SubscribedToContract<'bldr>> {
            let mut builder = SubscribedToContractBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            builder.add_at_peer_location(args.at_peer_location);
            builder.add_contract_location(args.contract_location);
            if let Some(x) = args.at_peer {
                builder.add_at_peer(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            if let Some(x) = args.transaction {
                builder.add_transaction(x);
            }
            if let Some(x) = args.requester {
                builder.add_requester(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn requester(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        SubscribedToContract::VT_REQUESTER,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn transaction(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        SubscribedToContract::VT_TRANSACTION,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SubscribedToContract::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(SubscribedToContract::VT_CONTRACT_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn at_peer(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        SubscribedToContract::VT_AT_PEER,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn at_peer_location(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(SubscribedToContract::VT_AT_PEER_LOCATION, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(SubscribedToContract::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SubscribedToContract<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "requester",
                    Self::VT_REQUESTER,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transaction",
                    Self::VT_TRANSACTION,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "at_peer",
                    Self::VT_AT_PEER,
                    true,
                )?
                .visit_field::<f64>("at_peer_location", Self::VT_AT_PEER_LOCATION, false)?
                .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SubscribedToContractArgs<'a> {
        pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
        pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub contract_location: f64,
        pub at_peer: Option<flatbuffers::WIPOffset<&'a str>>,
        pub at_peer_location: f64,
        pub timestamp: u64,
    }
    impl<'a> Default for SubscribedToContractArgs<'a> {
        #[inline]
        fn default() -> Self {
            SubscribedToContractArgs {
                requester: None,   // required field
                transaction: None, // required field
                key: None,         // required field
                contract_location: 0.0,
                at_peer: None, // required field
                at_peer_location: 0.0,
                timestamp: 0,
            }
        }
    }

    pub struct SubscribedToContractBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubscribedToContractBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubscribedToContract::VT_REQUESTER,
                requester,
            );
        }
        #[inline]
        pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubscribedToContract::VT_TRANSACTION,
                transaction,
            );
        }
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SubscribedToContract::VT_KEY, key);
        }
        #[inline]
        pub fn add_contract_location(&mut self, contract_location: f64) {
            self.fbb_.push_slot::<f64>(
                SubscribedToContract::VT_CONTRACT_LOCATION,
                contract_location,
                0.0,
            );
        }
        #[inline]
        pub fn add_at_peer(&mut self, at_peer: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubscribedToContract::VT_AT_PEER,
                at_peer,
            );
        }
        #[inline]
        pub fn add_at_peer_location(&mut self, at_peer_location: f64) {
            self.fbb_.push_slot::<f64>(
                SubscribedToContract::VT_AT_PEER_LOCATION,
                at_peer_location,
                0.0,
            );
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(SubscribedToContract::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SubscribedToContractBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SubscribedToContractBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SubscribedToContract<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, SubscribedToContract::VT_REQUESTER, "requester");
            self.fbb_
                .required(o, SubscribedToContract::VT_TRANSACTION, "transaction");
            self.fbb_.required(o, SubscribedToContract::VT_KEY, "key");
            self.fbb_
                .required(o, SubscribedToContract::VT_AT_PEER, "at_peer");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SubscribedToContract<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SubscribedToContract");
            ds.field("requester", &self.requester());
            ds.field("transaction", &self.transaction());
            ds.field("key", &self.key());
            ds.field("contract_location", &self.contract_location());
            ds.field("at_peer", &self.at_peer());
            ds.field("at_peer_location", &self.at_peer_location());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    pub enum ContractChangeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ContractChange<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ContractChange<'a> {
        type Inner = ContractChange<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ContractChange<'a> {
        pub const VT_CONTRACT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_CHANGE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_CHANGE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ContractChange { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ContractChangeArgs<'args>,
        ) -> flatbuffers::WIPOffset<ContractChange<'bldr>> {
            let mut builder = ContractChangeBuilder::new(_fbb);
            if let Some(x) = args.change {
                builder.add_change(x);
            }
            if let Some(x) = args.contract_id {
                builder.add_contract_id(x);
            }
            builder.add_change_type(args.change_type);
            builder.finish()
        }

        #[inline]
        pub fn contract_id(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ContractChange::VT_CONTRACT_ID, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn change_type(&self) -> ContractChangeType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ContractChangeType>(
                        ContractChange::VT_CHANGE_TYPE,
                        Some(ContractChangeType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn change(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        ContractChange::VT_CHANGE,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_put_request(&self) -> Option<PutRequest<'a>> {
            if self.change_type() == ContractChangeType::PutRequest {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { PutRequest::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_put_success(&self) -> Option<PutSuccess<'a>> {
            if self.change_type() == ContractChangeType::PutSuccess {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { PutSuccess::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_put_failure(&self) -> Option<PutFailure<'a>> {
            if self.change_type() == ContractChangeType::PutFailure {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { PutFailure::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_broadcast_emitted(&self) -> Option<BroadcastEmitted<'a>> {
            if self.change_type() == ContractChangeType::BroadcastEmitted {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BroadcastEmitted::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_broadcast_received(&self) -> Option<BroadcastReceived<'a>> {
            if self.change_type() == ContractChangeType::BroadcastReceived {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BroadcastReceived::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_update_request(&self) -> Option<UpdateRequest<'a>> {
            if self.change_type() == ContractChangeType::UpdateRequest {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UpdateRequest::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_update_success(&self) -> Option<UpdateSuccess<'a>> {
            if self.change_type() == ContractChangeType::UpdateSuccess {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UpdateSuccess::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_update_failure(&self) -> Option<UpdateFailure<'a>> {
            if self.change_type() == ContractChangeType::UpdateFailure {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UpdateFailure::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_get_contract(&self) -> Option<GetContract<'a>> {
            if self.change_type() == ContractChangeType::GetContract {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { GetContract::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn change_as_subscribed_to_contract(&self) -> Option<SubscribedToContract<'a>> {
            if self.change_type() == ContractChangeType::SubscribedToContract {
                self.change().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SubscribedToContract::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ContractChange<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("contract_id", Self::VT_CONTRACT_ID, true)?
     .visit_union::<ContractChangeType, _>("change_type", Self::VT_CHANGE_TYPE, "change", Self::VT_CHANGE, false, |key, v, pos| {
        match key {
          ContractChangeType::PutRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PutRequest>>("ContractChangeType::PutRequest", pos),
          ContractChangeType::PutSuccess => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PutSuccess>>("ContractChangeType::PutSuccess", pos),
          ContractChangeType::PutFailure => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PutFailure>>("ContractChangeType::PutFailure", pos),
          ContractChangeType::BroadcastEmitted => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BroadcastEmitted>>("ContractChangeType::BroadcastEmitted", pos),
          ContractChangeType::BroadcastReceived => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BroadcastReceived>>("ContractChangeType::BroadcastReceived", pos),
          ContractChangeType::UpdateRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpdateRequest>>("ContractChangeType::UpdateRequest", pos),
          ContractChangeType::UpdateSuccess => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpdateSuccess>>("ContractChangeType::UpdateSuccess", pos),
          ContractChangeType::UpdateFailure => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpdateFailure>>("ContractChangeType::UpdateFailure", pos),
          ContractChangeType::GetContract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetContract>>("ContractChangeType::GetContract", pos),
          ContractChangeType::SubscribedToContract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SubscribedToContract>>("ContractChangeType::SubscribedToContract", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ContractChangeArgs<'a> {
        pub contract_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub change_type: ContractChangeType,
        pub change: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ContractChangeArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContractChangeArgs {
                contract_id: None, // required field
                change_type: ContractChangeType::NONE,
                change: None,
            }
        }
    }

    pub struct ContractChangeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContractChangeBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_contract_id(&mut self, contract_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ContractChange::VT_CONTRACT_ID,
                contract_id,
            );
        }
        #[inline]
        pub fn add_change_type(&mut self, change_type: ContractChangeType) {
            self.fbb_.push_slot::<ContractChangeType>(
                ContractChange::VT_CHANGE_TYPE,
                change_type,
                ContractChangeType::NONE,
            );
        }
        #[inline]
        pub fn add_change(&mut self, change: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ContractChange::VT_CHANGE, change);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ContractChangeBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ContractChangeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ContractChange<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, ContractChange::VT_CONTRACT_ID, "contract_id");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ContractChange<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ContractChange");
            ds.field("contract_id", &self.contract_id());
            ds.field("change_type", &self.change_type());
            match self.change_type() {
                ContractChangeType::PutRequest => {
                    if let Some(x) = self.change_as_put_request() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::PutSuccess => {
                    if let Some(x) = self.change_as_put_success() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::PutFailure => {
                    if let Some(x) = self.change_as_put_failure() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::BroadcastEmitted => {
                    if let Some(x) = self.change_as_broadcast_emitted() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::BroadcastReceived => {
                    if let Some(x) = self.change_as_broadcast_received() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::UpdateRequest => {
                    if let Some(x) = self.change_as_update_request() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::UpdateSuccess => {
                    if let Some(x) = self.change_as_update_success() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::UpdateFailure => {
                    if let Some(x) = self.change_as_update_failure() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::GetContract => {
                    if let Some(x) = self.change_as_get_contract() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractChangeType::SubscribedToContract => {
                    if let Some(x) = self.change_as_subscribed_to_contract() {
                        ds.field("change", &x)
                    } else {
                        ds.field(
                            "change",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("change", &x)
                }
            };
            ds.finish()
        }
    }
} // pub mod topology
