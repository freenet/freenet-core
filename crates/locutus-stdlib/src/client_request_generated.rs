// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::common_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod client_request {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DELEGATE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DELEGATE_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DELEGATE_TYPE: [DelegateType; 2] = [
  DelegateType::NONE,
  DelegateType::WasmDelegateV1,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DelegateType(pub u8);
#[allow(non_upper_case_globals)]
impl DelegateType {
  pub const NONE: Self = Self(0);
  pub const WasmDelegateV1: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::WasmDelegateV1,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::WasmDelegateV1 => Some("WasmDelegateV1"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DelegateType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DelegateType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DelegateType {
    type Output = DelegateType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DelegateType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DelegateType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DelegateType {}
pub struct DelegateTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTRACT_REQUEST_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTRACT_REQUEST_TYPE: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTRACT_REQUEST_TYPE: [ContractRequestType; 5] = [
  ContractRequestType::NONE,
  ContractRequestType::Put,
  ContractRequestType::Update,
  ContractRequestType::Get,
  ContractRequestType::Subscribe,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ContractRequestType(pub u8);
#[allow(non_upper_case_globals)]
impl ContractRequestType {
  pub const NONE: Self = Self(0);
  pub const Put: Self = Self(1);
  pub const Update: Self = Self(2);
  pub const Get: Self = Self(3);
  pub const Subscribe: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Put,
    Self::Update,
    Self::Get,
    Self::Subscribe,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Put => Some("Put"),
      Self::Update => Some("Update"),
      Self::Get => Some("Get"),
      Self::Subscribe => Some("Subscribe"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ContractRequestType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ContractRequestType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ContractRequestType {
    type Output = ContractRequestType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ContractRequestType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ContractRequestType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ContractRequestType {}
pub struct ContractRequestTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INBOUND_DELEGATE_MSG_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INBOUND_DELEGATE_MSG_TYPE: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INBOUND_DELEGATE_MSG_TYPE: [InboundDelegateMsgType; 6] = [
  InboundDelegateMsgType::NONE,
  InboundDelegateMsgType::ApplicationMessage,
  InboundDelegateMsgType::GetSecretResponse,
  InboundDelegateMsgType::RandomBytes,
  InboundDelegateMsgType::UserInputResponse,
  InboundDelegateMsgType::GetSecretRequest,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct InboundDelegateMsgType(pub u8);
#[allow(non_upper_case_globals)]
impl InboundDelegateMsgType {
  pub const NONE: Self = Self(0);
  pub const ApplicationMessage: Self = Self(1);
  pub const GetSecretResponse: Self = Self(2);
  pub const RandomBytes: Self = Self(3);
  pub const UserInputResponse: Self = Self(4);
  pub const GetSecretRequest: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ApplicationMessage,
    Self::GetSecretResponse,
    Self::RandomBytes,
    Self::UserInputResponse,
    Self::GetSecretRequest,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ApplicationMessage => Some("ApplicationMessage"),
      Self::GetSecretResponse => Some("GetSecretResponse"),
      Self::RandomBytes => Some("RandomBytes"),
      Self::UserInputResponse => Some("UserInputResponse"),
      Self::GetSecretRequest => Some("GetSecretRequest"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for InboundDelegateMsgType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for InboundDelegateMsgType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for InboundDelegateMsgType {
    type Output = InboundDelegateMsgType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for InboundDelegateMsgType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for InboundDelegateMsgType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for InboundDelegateMsgType {}
pub struct InboundDelegateMsgTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DELEGATE_REQUEST_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DELEGATE_REQUEST_TYPE: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DELEGATE_REQUEST_TYPE: [DelegateRequestType; 5] = [
  DelegateRequestType::NONE,
  DelegateRequestType::ApplicationMessages,
  DelegateRequestType::GetSecretRequestType,
  DelegateRequestType::RegisterDelegate,
  DelegateRequestType::UnregisterDelegate,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DelegateRequestType(pub u8);
#[allow(non_upper_case_globals)]
impl DelegateRequestType {
  pub const NONE: Self = Self(0);
  pub const ApplicationMessages: Self = Self(1);
  pub const GetSecretRequestType: Self = Self(2);
  pub const RegisterDelegate: Self = Self(3);
  pub const UnregisterDelegate: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ApplicationMessages,
    Self::GetSecretRequestType,
    Self::RegisterDelegate,
    Self::UnregisterDelegate,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ApplicationMessages => Some("ApplicationMessages"),
      Self::GetSecretRequestType => Some("GetSecretRequestType"),
      Self::RegisterDelegate => Some("RegisterDelegate"),
      Self::UnregisterDelegate => Some("UnregisterDelegate"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DelegateRequestType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DelegateRequestType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DelegateRequestType {
    type Output = DelegateRequestType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DelegateRequestType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DelegateRequestType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DelegateRequestType {}
pub struct DelegateRequestTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CLIENT_REQUEST_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CLIENT_REQUEST_TYPE: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CLIENT_REQUEST_TYPE: [ClientRequestType; 5] = [
  ClientRequestType::NONE,
  ClientRequestType::ContractRequest,
  ClientRequestType::DelegateRequest,
  ClientRequestType::GenerateRandData,
  ClientRequestType::Disconnect,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ClientRequestType(pub u8);
#[allow(non_upper_case_globals)]
impl ClientRequestType {
  pub const NONE: Self = Self(0);
  pub const ContractRequest: Self = Self(1);
  pub const DelegateRequest: Self = Self(2);
  pub const GenerateRandData: Self = Self(3);
  pub const Disconnect: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ContractRequest,
    Self::DelegateRequest,
    Self::GenerateRandData,
    Self::Disconnect,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ContractRequest => Some("ContractRequest"),
      Self::DelegateRequest => Some("DelegateRequest"),
      Self::GenerateRandData => Some("GenerateRandData"),
      Self::Disconnect => Some("Disconnect"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ClientRequestType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ClientRequestType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ClientRequestType {
    type Output = ClientRequestType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ClientRequestType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ClientRequestType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ClientRequestType {}
pub struct ClientRequestTypeUnionTableOffset {}

pub enum DelegateCodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DelegateCode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelegateCode<'a> {
  type Inner = DelegateCode<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DelegateCode<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_CODE_HASH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DelegateCode { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DelegateCodeArgs<'args>
  ) -> flatbuffers::WIPOffset<DelegateCode<'bldr>> {
    let mut builder = DelegateCodeBuilder::new(_fbb);
    if let Some(x) = args.code_hash { builder.add_code_hash(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DelegateCode::VT_DATA, None).unwrap()}
  }
  #[inline]
  pub fn code_hash(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DelegateCode::VT_CODE_HASH, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for DelegateCode<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("code_hash", Self::VT_CODE_HASH, true)?
     .finish();
    Ok(())
  }
}
pub struct DelegateCodeArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub code_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DelegateCodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    DelegateCodeArgs {
      data: None, // required field
      code_hash: None, // required field
    }
  }
}

pub struct DelegateCodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelegateCodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateCode::VT_DATA, data);
  }
  #[inline]
  pub fn add_code_hash(&mut self, code_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateCode::VT_CODE_HASH, code_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelegateCodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DelegateCodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DelegateCode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DelegateCode::VT_DATA,"data");
    self.fbb_.required(o, DelegateCode::VT_CODE_HASH,"code_hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DelegateCode<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DelegateCode");
      ds.field("data", &self.data());
      ds.field("code_hash", &self.code_hash());
      ds.finish()
  }
}
pub enum DelegateKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DelegateKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelegateKey<'a> {
  type Inner = DelegateKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DelegateKey<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_CODE_HASH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DelegateKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DelegateKeyArgs<'args>
  ) -> flatbuffers::WIPOffset<DelegateKey<'bldr>> {
    let mut builder = DelegateKeyBuilder::new(_fbb);
    if let Some(x) = args.code_hash { builder.add_code_hash(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DelegateKey::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn code_hash(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DelegateKey::VT_CODE_HASH, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for DelegateKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("code_hash", Self::VT_CODE_HASH, true)?
     .finish();
    Ok(())
  }
}
pub struct DelegateKeyArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub code_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DelegateKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    DelegateKeyArgs {
      key: None, // required field
      code_hash: None, // required field
    }
  }
}

pub struct DelegateKeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelegateKeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateKey::VT_KEY, key);
  }
  #[inline]
  pub fn add_code_hash(&mut self, code_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateKey::VT_CODE_HASH, code_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelegateKeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DelegateKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DelegateKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DelegateKey::VT_KEY,"key");
    self.fbb_.required(o, DelegateKey::VT_CODE_HASH,"code_hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DelegateKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DelegateKey");
      ds.field("key", &self.key());
      ds.field("code_hash", &self.code_hash());
      ds.finish()
  }
}
pub enum DelegateContextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DelegateContext<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelegateContext<'a> {
  type Inner = DelegateContext<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DelegateContext<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DelegateContext { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DelegateContextArgs<'args>
  ) -> flatbuffers::WIPOffset<DelegateContext<'bldr>> {
    let mut builder = DelegateContextBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DelegateContext::VT_DATA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for DelegateContext<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, true)?
     .finish();
    Ok(())
  }
}
pub struct DelegateContextArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DelegateContextArgs<'a> {
  #[inline]
  fn default() -> Self {
    DelegateContextArgs {
      data: None, // required field
    }
  }
}

pub struct DelegateContextBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelegateContextBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateContext::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelegateContextBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DelegateContextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DelegateContext<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DelegateContext::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DelegateContext<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DelegateContext");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum WasmDelegateV1Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WasmDelegateV1<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WasmDelegateV1<'a> {
  type Inner = WasmDelegateV1<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WasmDelegateV1<'a> {
  pub const VT_PARAMETERS: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;
  pub const VT_KEY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WasmDelegateV1 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WasmDelegateV1Args<'args>
  ) -> flatbuffers::WIPOffset<WasmDelegateV1<'bldr>> {
    let mut builder = WasmDelegateV1Builder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.parameters { builder.add_parameters(x); }
    builder.finish()
  }


  #[inline]
  pub fn parameters(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(WasmDelegateV1::VT_PARAMETERS, None).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> DelegateCode<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DelegateCode>>(WasmDelegateV1::VT_DATA, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> DelegateKey<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DelegateKey>>(WasmDelegateV1::VT_KEY, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for WasmDelegateV1<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("parameters", Self::VT_PARAMETERS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DelegateCode>>("data", Self::VT_DATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DelegateKey>>("key", Self::VT_KEY, true)?
     .finish();
    Ok(())
  }
}
pub struct WasmDelegateV1Args<'a> {
    pub parameters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub data: Option<flatbuffers::WIPOffset<DelegateCode<'a>>>,
    pub key: Option<flatbuffers::WIPOffset<DelegateKey<'a>>>,
}
impl<'a> Default for WasmDelegateV1Args<'a> {
  #[inline]
  fn default() -> Self {
    WasmDelegateV1Args {
      parameters: None, // required field
      data: None, // required field
      key: None, // required field
    }
  }
}

pub struct WasmDelegateV1Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WasmDelegateV1Builder<'a, 'b> {
  #[inline]
  pub fn add_parameters(&mut self, parameters: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WasmDelegateV1::VT_PARAMETERS, parameters);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<DelegateCode<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DelegateCode>>(WasmDelegateV1::VT_DATA, data);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<DelegateKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DelegateKey>>(WasmDelegateV1::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WasmDelegateV1Builder<'a, 'b> {
    let start = _fbb.start_table();
    WasmDelegateV1Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WasmDelegateV1<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WasmDelegateV1::VT_PARAMETERS,"parameters");
    self.fbb_.required(o, WasmDelegateV1::VT_DATA,"data");
    self.fbb_.required(o, WasmDelegateV1::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WasmDelegateV1<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WasmDelegateV1");
      ds.field("parameters", &self.parameters());
      ds.field("data", &self.data());
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum DelegateContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DelegateContainer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelegateContainer<'a> {
  type Inner = DelegateContainer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DelegateContainer<'a> {
  pub const VT_DELEGATE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DELEGATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DelegateContainer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DelegateContainerArgs
  ) -> flatbuffers::WIPOffset<DelegateContainer<'bldr>> {
    let mut builder = DelegateContainerBuilder::new(_fbb);
    if let Some(x) = args.delegate { builder.add_delegate(x); }
    builder.add_delegate_type(args.delegate_type);
    builder.finish()
  }


  #[inline]
  pub fn delegate_type(&self) -> DelegateType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DelegateType>(DelegateContainer::VT_DELEGATE_TYPE, Some(DelegateType::NONE)).unwrap()}
  }
  #[inline]
  pub fn delegate(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DelegateContainer::VT_DELEGATE, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn delegate_as_wasm_delegate_v1(&self) -> Option<WasmDelegateV1<'a>> {
    if self.delegate_type() == DelegateType::WasmDelegateV1 {
      let u = self.delegate();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { WasmDelegateV1::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DelegateContainer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<DelegateType, _>("delegate_type", Self::VT_DELEGATE_TYPE, "delegate", Self::VT_DELEGATE, true, |key, v, pos| {
        match key {
          DelegateType::WasmDelegateV1 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WasmDelegateV1>>("DelegateType::WasmDelegateV1", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct DelegateContainerArgs {
    pub delegate_type: DelegateType,
    pub delegate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DelegateContainerArgs {
  #[inline]
  fn default() -> Self {
    DelegateContainerArgs {
      delegate_type: DelegateType::NONE,
      delegate: None, // required field
    }
  }
}

pub struct DelegateContainerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelegateContainerBuilder<'a, 'b> {
  #[inline]
  pub fn add_delegate_type(&mut self, delegate_type: DelegateType) {
    self.fbb_.push_slot::<DelegateType>(DelegateContainer::VT_DELEGATE_TYPE, delegate_type, DelegateType::NONE);
  }
  #[inline]
  pub fn add_delegate(&mut self, delegate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateContainer::VT_DELEGATE, delegate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelegateContainerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DelegateContainerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DelegateContainer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DelegateContainer::VT_DELEGATE,"delegate");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DelegateContainer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DelegateContainer");
      ds.field("delegate_type", &self.delegate_type());
      match self.delegate_type() {
        DelegateType::WasmDelegateV1 => {
          if let Some(x) = self.delegate_as_wasm_delegate_v1() {
            ds.field("delegate", &x)
          } else {
            ds.field("delegate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("delegate", &x)
        },
      };
      ds.finish()
  }
}
pub enum RelatedContractOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelatedContract<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelatedContract<'a> {
  type Inner = RelatedContract<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelatedContract<'a> {
  pub const VT_INSTANCE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelatedContract { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RelatedContractArgs<'args>
  ) -> flatbuffers::WIPOffset<RelatedContract<'bldr>> {
    let mut builder = RelatedContractBuilder::new(_fbb);
    if let Some(x) = args.state { builder.add_state(x); }
    if let Some(x) = args.instance_id { builder.add_instance_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn instance_id(&self) -> super::common::ContractInstanceId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ContractInstanceId>>(RelatedContract::VT_INSTANCE_ID, None).unwrap()}
  }
  #[inline]
  pub fn state(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RelatedContract::VT_STATE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RelatedContract<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractInstanceId>>("instance_id", Self::VT_INSTANCE_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("state", Self::VT_STATE, true)?
     .finish();
    Ok(())
  }
}
pub struct RelatedContractArgs<'a> {
    pub instance_id: Option<flatbuffers::WIPOffset<super::common::ContractInstanceId<'a>>>,
    pub state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RelatedContractArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelatedContractArgs {
      instance_id: None, // required field
      state: None, // required field
    }
  }
}

pub struct RelatedContractBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelatedContractBuilder<'a, 'b> {
  #[inline]
  pub fn add_instance_id(&mut self, instance_id: flatbuffers::WIPOffset<super::common::ContractInstanceId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ContractInstanceId>>(RelatedContract::VT_INSTANCE_ID, instance_id);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelatedContract::VT_STATE, state);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelatedContractBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelatedContractBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelatedContract<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RelatedContract::VT_INSTANCE_ID,"instance_id");
    self.fbb_.required(o, RelatedContract::VT_STATE,"state");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelatedContract<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelatedContract");
      ds.field("instance_id", &self.instance_id());
      ds.field("state", &self.state());
      ds.finish()
  }
}
pub enum RelatedContractsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelatedContracts<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelatedContracts<'a> {
  type Inner = RelatedContracts<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelatedContracts<'a> {
  pub const VT_CONTRACTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelatedContracts { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RelatedContractsArgs<'args>
  ) -> flatbuffers::WIPOffset<RelatedContracts<'bldr>> {
    let mut builder = RelatedContractsBuilder::new(_fbb);
    if let Some(x) = args.contracts { builder.add_contracts(x); }
    builder.finish()
  }


  #[inline]
  pub fn contracts(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelatedContract<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelatedContract>>>>(RelatedContracts::VT_CONTRACTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RelatedContracts<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RelatedContract>>>>("contracts", Self::VT_CONTRACTS, true)?
     .finish();
    Ok(())
  }
}
pub struct RelatedContractsArgs<'a> {
    pub contracts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelatedContract<'a>>>>>,
}
impl<'a> Default for RelatedContractsArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelatedContractsArgs {
      contracts: None, // required field
    }
  }
}

pub struct RelatedContractsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelatedContractsBuilder<'a, 'b> {
  #[inline]
  pub fn add_contracts(&mut self, contracts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RelatedContract<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelatedContracts::VT_CONTRACTS, contracts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelatedContractsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelatedContractsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelatedContracts<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RelatedContracts::VT_CONTRACTS,"contracts");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelatedContracts<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelatedContracts");
      ds.field("contracts", &self.contracts());
      ds.finish()
  }
}
pub enum PutOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Put<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Put<'a> {
  type Inner = Put<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Put<'a> {
  pub const VT_CONTAINER: flatbuffers::VOffsetT = 4;
  pub const VT_WRAPPED_STATE: flatbuffers::VOffsetT = 6;
  pub const VT_RELATED_CONTRACTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Put { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PutArgs<'args>
  ) -> flatbuffers::WIPOffset<Put<'bldr>> {
    let mut builder = PutBuilder::new(_fbb);
    if let Some(x) = args.related_contracts { builder.add_related_contracts(x); }
    if let Some(x) = args.wrapped_state { builder.add_wrapped_state(x); }
    if let Some(x) = args.container { builder.add_container(x); }
    builder.finish()
  }


  #[inline]
  pub fn container(&self) -> super::common::ContractContainer<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ContractContainer>>(Put::VT_CONTAINER, None).unwrap()}
  }
  #[inline]
  pub fn wrapped_state(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Put::VT_WRAPPED_STATE, None).unwrap()}
  }
  #[inline]
  pub fn related_contracts(&self) -> RelatedContracts<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RelatedContracts>>(Put::VT_RELATED_CONTRACTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Put<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractContainer>>("container", Self::VT_CONTAINER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("wrapped_state", Self::VT_WRAPPED_STATE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<RelatedContracts>>("related_contracts", Self::VT_RELATED_CONTRACTS, true)?
     .finish();
    Ok(())
  }
}
pub struct PutArgs<'a> {
    pub container: Option<flatbuffers::WIPOffset<super::common::ContractContainer<'a>>>,
    pub wrapped_state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub related_contracts: Option<flatbuffers::WIPOffset<RelatedContracts<'a>>>,
}
impl<'a> Default for PutArgs<'a> {
  #[inline]
  fn default() -> Self {
    PutArgs {
      container: None, // required field
      wrapped_state: None, // required field
      related_contracts: None, // required field
    }
  }
}

pub struct PutBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PutBuilder<'a, 'b> {
  #[inline]
  pub fn add_container(&mut self, container: flatbuffers::WIPOffset<super::common::ContractContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ContractContainer>>(Put::VT_CONTAINER, container);
  }
  #[inline]
  pub fn add_wrapped_state(&mut self, wrapped_state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Put::VT_WRAPPED_STATE, wrapped_state);
  }
  #[inline]
  pub fn add_related_contracts(&mut self, related_contracts: flatbuffers::WIPOffset<RelatedContracts<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RelatedContracts>>(Put::VT_RELATED_CONTRACTS, related_contracts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PutBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PutBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Put<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Put::VT_CONTAINER,"container");
    self.fbb_.required(o, Put::VT_WRAPPED_STATE,"wrapped_state");
    self.fbb_.required(o, Put::VT_RELATED_CONTRACTS,"related_contracts");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Put<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Put");
      ds.field("container", &self.container());
      ds.field("wrapped_state", &self.wrapped_state());
      ds.field("related_contracts", &self.related_contracts());
      ds.finish()
  }
}
pub enum UpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Update<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Update<'a> {
  type Inner = Update<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Update<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Update { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<Update<'bldr>> {
    let mut builder = UpdateBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> super::common::ContractKey<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(Update::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> super::common::UpdateData<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::UpdateData>>(Update::VT_DATA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Update<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::UpdateData>>("data", Self::VT_DATA, true)?
     .finish();
    Ok(())
  }
}
pub struct UpdateArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<super::common::ContractKey<'a>>>,
    pub data: Option<flatbuffers::WIPOffset<super::common::UpdateData<'a>>>,
}
impl<'a> Default for UpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    UpdateArgs {
      key: None, // required field
      data: None, // required field
    }
  }
}

pub struct UpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::ContractKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ContractKey>>(Update::VT_KEY, key);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<super::common::UpdateData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::UpdateData>>(Update::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Update<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Update::VT_KEY,"key");
    self.fbb_.required(o, Update::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Update<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Update");
      ds.field("key", &self.key());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum GetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Get<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Get<'a> {
  type Inner = Get<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Get<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_FETCH_CONTRACT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Get { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetArgs<'args>
  ) -> flatbuffers::WIPOffset<Get<'bldr>> {
    let mut builder = GetBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_fetch_contract(args.fetch_contract);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> super::common::ContractKey<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(Get::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn fetch_contract(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Get::VT_FETCH_CONTRACT, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Get<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>("key", Self::VT_KEY, true)?
     .visit_field::<bool>("fetch_contract", Self::VT_FETCH_CONTRACT, false)?
     .finish();
    Ok(())
  }
}
pub struct GetArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<super::common::ContractKey<'a>>>,
    pub fetch_contract: bool,
}
impl<'a> Default for GetArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetArgs {
      key: None, // required field
      fetch_contract: false,
    }
  }
}

pub struct GetBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::ContractKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ContractKey>>(Get::VT_KEY, key);
  }
  #[inline]
  pub fn add_fetch_contract(&mut self, fetch_contract: bool) {
    self.fbb_.push_slot::<bool>(Get::VT_FETCH_CONTRACT, fetch_contract, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Get<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Get::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Get<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Get");
      ds.field("key", &self.key());
      ds.field("fetch_contract", &self.fetch_contract());
      ds.finish()
  }
}
pub enum SubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Subscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Subscribe<'a> {
  type Inner = Subscribe<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Subscribe<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_SUMMARY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Subscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubscribeArgs<'args>
  ) -> flatbuffers::WIPOffset<Subscribe<'bldr>> {
    let mut builder = SubscribeBuilder::new(_fbb);
    if let Some(x) = args.summary { builder.add_summary(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> super::common::ContractKey<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(Subscribe::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn summary(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Subscribe::VT_SUMMARY, None)}
  }
}

impl flatbuffers::Verifiable for Subscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("summary", Self::VT_SUMMARY, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscribeArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<super::common::ContractKey<'a>>>,
    pub summary: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SubscribeArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscribeArgs {
      key: None, // required field
      summary: None,
    }
  }
}

pub struct SubscribeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubscribeBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::ContractKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ContractKey>>(Subscribe::VT_KEY, key);
  }
  #[inline]
  pub fn add_summary(&mut self, summary: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscribe::VT_SUMMARY, summary);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubscribeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Subscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Subscribe::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Subscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Subscribe");
      ds.field("key", &self.key());
      ds.field("summary", &self.summary());
      ds.finish()
  }
}
pub enum ApplicationMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ApplicationMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ApplicationMessage<'a> {
  type Inner = ApplicationMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ApplicationMessage<'a> {
  pub const VT_APP: flatbuffers::VOffsetT = 4;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;
  pub const VT_CONTEXT: flatbuffers::VOffsetT = 8;
  pub const VT_PROCESSED: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ApplicationMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ApplicationMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<ApplicationMessage<'bldr>> {
    let mut builder = ApplicationMessageBuilder::new(_fbb);
    if let Some(x) = args.context { builder.add_context(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.app { builder.add_app(x); }
    builder.add_processed(args.processed);
    builder.finish()
  }


  #[inline]
  pub fn app(&self) -> super::common::ContractInstanceId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ContractInstanceId>>(ApplicationMessage::VT_APP, None).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ApplicationMessage::VT_PAYLOAD, None).unwrap()}
  }
  #[inline]
  pub fn context(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ApplicationMessage::VT_CONTEXT, None).unwrap()}
  }
  #[inline]
  pub fn processed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ApplicationMessage::VT_PROCESSED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ApplicationMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractInstanceId>>("app", Self::VT_APP, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("context", Self::VT_CONTEXT, true)?
     .visit_field::<bool>("processed", Self::VT_PROCESSED, false)?
     .finish();
    Ok(())
  }
}
pub struct ApplicationMessageArgs<'a> {
    pub app: Option<flatbuffers::WIPOffset<super::common::ContractInstanceId<'a>>>,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub context: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub processed: bool,
}
impl<'a> Default for ApplicationMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    ApplicationMessageArgs {
      app: None, // required field
      payload: None, // required field
      context: None, // required field
      processed: false,
    }
  }
}

pub struct ApplicationMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ApplicationMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_app(&mut self, app: flatbuffers::WIPOffset<super::common::ContractInstanceId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ContractInstanceId>>(ApplicationMessage::VT_APP, app);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ApplicationMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_context(&mut self, context: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ApplicationMessage::VT_CONTEXT, context);
  }
  #[inline]
  pub fn add_processed(&mut self, processed: bool) {
    self.fbb_.push_slot::<bool>(ApplicationMessage::VT_PROCESSED, processed, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ApplicationMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ApplicationMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ApplicationMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ApplicationMessage::VT_APP,"app");
    self.fbb_.required(o, ApplicationMessage::VT_PAYLOAD,"payload");
    self.fbb_.required(o, ApplicationMessage::VT_CONTEXT,"context");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ApplicationMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ApplicationMessage");
      ds.field("app", &self.app());
      ds.field("payload", &self.payload());
      ds.field("context", &self.context());
      ds.field("processed", &self.processed());
      ds.finish()
  }
}
pub enum GetSecretResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetSecretResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetSecretResponse<'a> {
  type Inner = GetSecretResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetSecretResponse<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_CONTEXT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetSecretResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetSecretResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetSecretResponse<'bldr>> {
    let mut builder = GetSecretResponseBuilder::new(_fbb);
    if let Some(x) = args.context { builder.add_context(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> super::common::SecretsId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::SecretsId>>(GetSecretResponse::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetSecretResponse::VT_VALUE, None)}
  }
  #[inline]
  pub fn context(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetSecretResponse::VT_CONTEXT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetSecretResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::SecretsId>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("context", Self::VT_CONTEXT, true)?
     .finish();
    Ok(())
  }
}
pub struct GetSecretResponseArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<super::common::SecretsId<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub context: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GetSecretResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetSecretResponseArgs {
      key: None, // required field
      value: None,
      context: None, // required field
    }
  }
}

pub struct GetSecretResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetSecretResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::SecretsId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::SecretsId>>(GetSecretResponse::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetSecretResponse::VT_VALUE, value);
  }
  #[inline]
  pub fn add_context(&mut self, context: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetSecretResponse::VT_CONTEXT, context);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetSecretResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetSecretResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetSecretResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, GetSecretResponse::VT_KEY,"key");
    self.fbb_.required(o, GetSecretResponse::VT_CONTEXT,"context");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetSecretResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetSecretResponse");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.field("context", &self.context());
      ds.finish()
  }
}
pub enum RandomBytesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RandomBytes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RandomBytes<'a> {
  type Inner = RandomBytes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RandomBytes<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RandomBytes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RandomBytesArgs<'args>
  ) -> flatbuffers::WIPOffset<RandomBytes<'bldr>> {
    let mut builder = RandomBytesBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RandomBytes::VT_DATA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RandomBytes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, true)?
     .finish();
    Ok(())
  }
}
pub struct RandomBytesArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RandomBytesArgs<'a> {
  #[inline]
  fn default() -> Self {
    RandomBytesArgs {
      data: None, // required field
    }
  }
}

pub struct RandomBytesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RandomBytesBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RandomBytes::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RandomBytesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RandomBytesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RandomBytes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RandomBytes::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RandomBytes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RandomBytes");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum ClientResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClientResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClientResponse<'a> {
  type Inner = ClientResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ClientResponse<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClientResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ClientResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<ClientResponse<'bldr>> {
    let mut builder = ClientResponseBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ClientResponse::VT_DATA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ClientResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, true)?
     .finish();
    Ok(())
  }
}
pub struct ClientResponseArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ClientResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ClientResponseArgs {
      data: None, // required field
    }
  }
}

pub struct ClientResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ClientResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientResponse::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ClientResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ClientResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClientResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ClientResponse::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClientResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClientResponse");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum UserInputResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UserInputResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UserInputResponse<'a> {
  type Inner = UserInputResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UserInputResponse<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_RESPONSE: flatbuffers::VOffsetT = 6;
  pub const VT_DELEGATE_CONTEXT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UserInputResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UserInputResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<UserInputResponse<'bldr>> {
    let mut builder = UserInputResponseBuilder::new(_fbb);
    if let Some(x) = args.delegate_context { builder.add_delegate_context(x); }
    if let Some(x) = args.response { builder.add_response(x); }
    builder.add_request_id(args.request_id);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UserInputResponse::VT_REQUEST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn response(&self) -> ClientResponse<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ClientResponse>>(UserInputResponse::VT_RESPONSE, None).unwrap()}
  }
  #[inline]
  pub fn delegate_context(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(UserInputResponse::VT_DELEGATE_CONTEXT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for UserInputResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ClientResponse>>("response", Self::VT_RESPONSE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("delegate_context", Self::VT_DELEGATE_CONTEXT, true)?
     .finish();
    Ok(())
  }
}
pub struct UserInputResponseArgs<'a> {
    pub request_id: u32,
    pub response: Option<flatbuffers::WIPOffset<ClientResponse<'a>>>,
    pub delegate_context: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for UserInputResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    UserInputResponseArgs {
      request_id: 0,
      response: None, // required field
      delegate_context: None, // required field
    }
  }
}

pub struct UserInputResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UserInputResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: u32) {
    self.fbb_.push_slot::<u32>(UserInputResponse::VT_REQUEST_ID, request_id, 0);
  }
  #[inline]
  pub fn add_response(&mut self, response: flatbuffers::WIPOffset<ClientResponse<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ClientResponse>>(UserInputResponse::VT_RESPONSE, response);
  }
  #[inline]
  pub fn add_delegate_context(&mut self, delegate_context: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInputResponse::VT_DELEGATE_CONTEXT, delegate_context);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UserInputResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UserInputResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UserInputResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, UserInputResponse::VT_RESPONSE,"response");
    self.fbb_.required(o, UserInputResponse::VT_DELEGATE_CONTEXT,"delegate_context");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UserInputResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UserInputResponse");
      ds.field("request_id", &self.request_id());
      ds.field("response", &self.response());
      ds.field("delegate_context", &self.delegate_context());
      ds.finish()
  }
}
pub enum InboundDelegateMsgOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InboundDelegateMsg<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InboundDelegateMsg<'a> {
  type Inner = InboundDelegateMsg<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InboundDelegateMsg<'a> {
  pub const VT_INBOUND_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_INBOUND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InboundDelegateMsg { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InboundDelegateMsgArgs
  ) -> flatbuffers::WIPOffset<InboundDelegateMsg<'bldr>> {
    let mut builder = InboundDelegateMsgBuilder::new(_fbb);
    if let Some(x) = args.inbound { builder.add_inbound(x); }
    builder.add_inbound_type(args.inbound_type);
    builder.finish()
  }


  #[inline]
  pub fn inbound_type(&self) -> InboundDelegateMsgType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<InboundDelegateMsgType>(InboundDelegateMsg::VT_INBOUND_TYPE, Some(InboundDelegateMsgType::NONE)).unwrap()}
  }
  #[inline]
  pub fn inbound(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(InboundDelegateMsg::VT_INBOUND, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn inbound_as_application_message(&self) -> Option<ApplicationMessage<'a>> {
    if self.inbound_type() == InboundDelegateMsgType::ApplicationMessage {
      let u = self.inbound();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ApplicationMessage::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inbound_as_get_secret_response(&self) -> Option<GetSecretResponse<'a>> {
    if self.inbound_type() == InboundDelegateMsgType::GetSecretResponse {
      let u = self.inbound();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { GetSecretResponse::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inbound_as_random_bytes(&self) -> Option<RandomBytes<'a>> {
    if self.inbound_type() == InboundDelegateMsgType::RandomBytes {
      let u = self.inbound();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { RandomBytes::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inbound_as_user_input_response(&self) -> Option<UserInputResponse<'a>> {
    if self.inbound_type() == InboundDelegateMsgType::UserInputResponse {
      let u = self.inbound();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { UserInputResponse::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inbound_as_get_secret_request(&self) -> Option<GetSecretRequest<'a>> {
    if self.inbound_type() == InboundDelegateMsgType::GetSecretRequest {
      let u = self.inbound();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { GetSecretRequest::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for InboundDelegateMsg<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<InboundDelegateMsgType, _>("inbound_type", Self::VT_INBOUND_TYPE, "inbound", Self::VT_INBOUND, true, |key, v, pos| {
        match key {
          InboundDelegateMsgType::ApplicationMessage => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ApplicationMessage>>("InboundDelegateMsgType::ApplicationMessage", pos),
          InboundDelegateMsgType::GetSecretResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetSecretResponse>>("InboundDelegateMsgType::GetSecretResponse", pos),
          InboundDelegateMsgType::RandomBytes => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RandomBytes>>("InboundDelegateMsgType::RandomBytes", pos),
          InboundDelegateMsgType::UserInputResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UserInputResponse>>("InboundDelegateMsgType::UserInputResponse", pos),
          InboundDelegateMsgType::GetSecretRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetSecretRequest>>("InboundDelegateMsgType::GetSecretRequest", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct InboundDelegateMsgArgs {
    pub inbound_type: InboundDelegateMsgType,
    pub inbound: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for InboundDelegateMsgArgs {
  #[inline]
  fn default() -> Self {
    InboundDelegateMsgArgs {
      inbound_type: InboundDelegateMsgType::NONE,
      inbound: None, // required field
    }
  }
}

pub struct InboundDelegateMsgBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InboundDelegateMsgBuilder<'a, 'b> {
  #[inline]
  pub fn add_inbound_type(&mut self, inbound_type: InboundDelegateMsgType) {
    self.fbb_.push_slot::<InboundDelegateMsgType>(InboundDelegateMsg::VT_INBOUND_TYPE, inbound_type, InboundDelegateMsgType::NONE);
  }
  #[inline]
  pub fn add_inbound(&mut self, inbound: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InboundDelegateMsg::VT_INBOUND, inbound);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InboundDelegateMsgBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InboundDelegateMsgBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InboundDelegateMsg<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, InboundDelegateMsg::VT_INBOUND,"inbound");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InboundDelegateMsg<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InboundDelegateMsg");
      ds.field("inbound_type", &self.inbound_type());
      match self.inbound_type() {
        InboundDelegateMsgType::ApplicationMessage => {
          if let Some(x) = self.inbound_as_application_message() {
            ds.field("inbound", &x)
          } else {
            ds.field("inbound", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        InboundDelegateMsgType::GetSecretResponse => {
          if let Some(x) = self.inbound_as_get_secret_response() {
            ds.field("inbound", &x)
          } else {
            ds.field("inbound", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        InboundDelegateMsgType::RandomBytes => {
          if let Some(x) = self.inbound_as_random_bytes() {
            ds.field("inbound", &x)
          } else {
            ds.field("inbound", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        InboundDelegateMsgType::UserInputResponse => {
          if let Some(x) = self.inbound_as_user_input_response() {
            ds.field("inbound", &x)
          } else {
            ds.field("inbound", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        InboundDelegateMsgType::GetSecretRequest => {
          if let Some(x) = self.inbound_as_get_secret_request() {
            ds.field("inbound", &x)
          } else {
            ds.field("inbound", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("inbound", &x)
        },
      };
      ds.finish()
  }
}
pub enum ApplicationMessagesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ApplicationMessages<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ApplicationMessages<'a> {
  type Inner = ApplicationMessages<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ApplicationMessages<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 6;
  pub const VT_INBOUND: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ApplicationMessages { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ApplicationMessagesArgs<'args>
  ) -> flatbuffers::WIPOffset<ApplicationMessages<'bldr>> {
    let mut builder = ApplicationMessagesBuilder::new(_fbb);
    if let Some(x) = args.inbound { builder.add_inbound(x); }
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> DelegateKey<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DelegateKey>>(ApplicationMessages::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn params(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ApplicationMessages::VT_PARAMS, None).unwrap()}
  }
  #[inline]
  pub fn inbound(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InboundDelegateMsg<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InboundDelegateMsg>>>>(ApplicationMessages::VT_INBOUND, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ApplicationMessages<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DelegateKey>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("params", Self::VT_PARAMS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InboundDelegateMsg>>>>("inbound", Self::VT_INBOUND, true)?
     .finish();
    Ok(())
  }
}
pub struct ApplicationMessagesArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<DelegateKey<'a>>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub inbound: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InboundDelegateMsg<'a>>>>>,
}
impl<'a> Default for ApplicationMessagesArgs<'a> {
  #[inline]
  fn default() -> Self {
    ApplicationMessagesArgs {
      key: None, // required field
      params: None, // required field
      inbound: None, // required field
    }
  }
}

pub struct ApplicationMessagesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ApplicationMessagesBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<DelegateKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DelegateKey>>(ApplicationMessages::VT_KEY, key);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ApplicationMessages::VT_PARAMS, params);
  }
  #[inline]
  pub fn add_inbound(&mut self, inbound: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InboundDelegateMsg<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ApplicationMessages::VT_INBOUND, inbound);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ApplicationMessagesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ApplicationMessagesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ApplicationMessages<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ApplicationMessages::VT_KEY,"key");
    self.fbb_.required(o, ApplicationMessages::VT_PARAMS,"params");
    self.fbb_.required(o, ApplicationMessages::VT_INBOUND,"inbound");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ApplicationMessages<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ApplicationMessages");
      ds.field("key", &self.key());
      ds.field("params", &self.params());
      ds.field("inbound", &self.inbound());
      ds.finish()
  }
}
pub enum GetSecretRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetSecretRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetSecretRequest<'a> {
  type Inner = GetSecretRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetSecretRequest<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_DELEGATE_CONTEXT: flatbuffers::VOffsetT = 6;
  pub const VT_PROCESSED: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetSecretRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetSecretRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetSecretRequest<'bldr>> {
    let mut builder = GetSecretRequestBuilder::new(_fbb);
    if let Some(x) = args.delegate_context { builder.add_delegate_context(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_processed(args.processed);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> super::common::SecretsId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::SecretsId>>(GetSecretRequest::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn delegate_context(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetSecretRequest::VT_DELEGATE_CONTEXT, None).unwrap()}
  }
  #[inline]
  pub fn processed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetSecretRequest::VT_PROCESSED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetSecretRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::SecretsId>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("delegate_context", Self::VT_DELEGATE_CONTEXT, true)?
     .visit_field::<bool>("processed", Self::VT_PROCESSED, false)?
     .finish();
    Ok(())
  }
}
pub struct GetSecretRequestArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<super::common::SecretsId<'a>>>,
    pub delegate_context: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub processed: bool,
}
impl<'a> Default for GetSecretRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetSecretRequestArgs {
      key: None, // required field
      delegate_context: None, // required field
      processed: false,
    }
  }
}

pub struct GetSecretRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetSecretRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::SecretsId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::SecretsId>>(GetSecretRequest::VT_KEY, key);
  }
  #[inline]
  pub fn add_delegate_context(&mut self, delegate_context: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetSecretRequest::VT_DELEGATE_CONTEXT, delegate_context);
  }
  #[inline]
  pub fn add_processed(&mut self, processed: bool) {
    self.fbb_.push_slot::<bool>(GetSecretRequest::VT_PROCESSED, processed, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetSecretRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetSecretRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetSecretRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, GetSecretRequest::VT_KEY,"key");
    self.fbb_.required(o, GetSecretRequest::VT_DELEGATE_CONTEXT,"delegate_context");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetSecretRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetSecretRequest");
      ds.field("key", &self.key());
      ds.field("delegate_context", &self.delegate_context());
      ds.field("processed", &self.processed());
      ds.finish()
  }
}
pub enum GetSecretRequestTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetSecretRequestType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetSecretRequestType<'a> {
  type Inner = GetSecretRequestType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetSecretRequestType<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 6;
  pub const VT_GET_REQUEST: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetSecretRequestType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetSecretRequestTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<GetSecretRequestType<'bldr>> {
    let mut builder = GetSecretRequestTypeBuilder::new(_fbb);
    if let Some(x) = args.get_request { builder.add_get_request(x); }
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> DelegateKey<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DelegateKey>>(GetSecretRequestType::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn params(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetSecretRequestType::VT_PARAMS, None).unwrap()}
  }
  #[inline]
  pub fn get_request(&self) -> GetSecretRequest<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GetSecretRequest>>(GetSecretRequestType::VT_GET_REQUEST, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetSecretRequestType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DelegateKey>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("params", Self::VT_PARAMS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<GetSecretRequest>>("get_request", Self::VT_GET_REQUEST, true)?
     .finish();
    Ok(())
  }
}
pub struct GetSecretRequestTypeArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<DelegateKey<'a>>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub get_request: Option<flatbuffers::WIPOffset<GetSecretRequest<'a>>>,
}
impl<'a> Default for GetSecretRequestTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetSecretRequestTypeArgs {
      key: None, // required field
      params: None, // required field
      get_request: None, // required field
    }
  }
}

pub struct GetSecretRequestTypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetSecretRequestTypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<DelegateKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DelegateKey>>(GetSecretRequestType::VT_KEY, key);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetSecretRequestType::VT_PARAMS, params);
  }
  #[inline]
  pub fn add_get_request(&mut self, get_request: flatbuffers::WIPOffset<GetSecretRequest<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GetSecretRequest>>(GetSecretRequestType::VT_GET_REQUEST, get_request);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetSecretRequestTypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetSecretRequestTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetSecretRequestType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, GetSecretRequestType::VT_KEY,"key");
    self.fbb_.required(o, GetSecretRequestType::VT_PARAMS,"params");
    self.fbb_.required(o, GetSecretRequestType::VT_GET_REQUEST,"get_request");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetSecretRequestType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetSecretRequestType");
      ds.field("key", &self.key());
      ds.field("params", &self.params());
      ds.field("get_request", &self.get_request());
      ds.finish()
  }
}
pub enum RegisterDelegateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RegisterDelegate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RegisterDelegate<'a> {
  type Inner = RegisterDelegate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RegisterDelegate<'a> {
  pub const VT_DELEGATE: flatbuffers::VOffsetT = 4;
  pub const VT_CIPHER: flatbuffers::VOffsetT = 6;
  pub const VT_NONCE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RegisterDelegate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RegisterDelegateArgs<'args>
  ) -> flatbuffers::WIPOffset<RegisterDelegate<'bldr>> {
    let mut builder = RegisterDelegateBuilder::new(_fbb);
    if let Some(x) = args.nonce { builder.add_nonce(x); }
    if let Some(x) = args.cipher { builder.add_cipher(x); }
    if let Some(x) = args.delegate { builder.add_delegate(x); }
    builder.finish()
  }


  #[inline]
  pub fn delegate(&self) -> DelegateContainer<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DelegateContainer>>(RegisterDelegate::VT_DELEGATE, None).unwrap()}
  }
  #[inline]
  pub fn cipher(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RegisterDelegate::VT_CIPHER, None).unwrap()}
  }
  #[inline]
  pub fn nonce(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RegisterDelegate::VT_NONCE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RegisterDelegate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DelegateContainer>>("delegate", Self::VT_DELEGATE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("cipher", Self::VT_CIPHER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("nonce", Self::VT_NONCE, true)?
     .finish();
    Ok(())
  }
}
pub struct RegisterDelegateArgs<'a> {
    pub delegate: Option<flatbuffers::WIPOffset<DelegateContainer<'a>>>,
    pub cipher: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RegisterDelegateArgs<'a> {
  #[inline]
  fn default() -> Self {
    RegisterDelegateArgs {
      delegate: None, // required field
      cipher: None, // required field
      nonce: None, // required field
    }
  }
}

pub struct RegisterDelegateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RegisterDelegateBuilder<'a, 'b> {
  #[inline]
  pub fn add_delegate(&mut self, delegate: flatbuffers::WIPOffset<DelegateContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DelegateContainer>>(RegisterDelegate::VT_DELEGATE, delegate);
  }
  #[inline]
  pub fn add_cipher(&mut self, cipher: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RegisterDelegate::VT_CIPHER, cipher);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RegisterDelegate::VT_NONCE, nonce);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RegisterDelegateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RegisterDelegateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RegisterDelegate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RegisterDelegate::VT_DELEGATE,"delegate");
    self.fbb_.required(o, RegisterDelegate::VT_CIPHER,"cipher");
    self.fbb_.required(o, RegisterDelegate::VT_NONCE,"nonce");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RegisterDelegate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RegisterDelegate");
      ds.field("delegate", &self.delegate());
      ds.field("cipher", &self.cipher());
      ds.field("nonce", &self.nonce());
      ds.finish()
  }
}
pub enum UnregisterDelegateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnregisterDelegate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnregisterDelegate<'a> {
  type Inner = UnregisterDelegate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnregisterDelegate<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnregisterDelegate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnregisterDelegateArgs<'args>
  ) -> flatbuffers::WIPOffset<UnregisterDelegate<'bldr>> {
    let mut builder = UnregisterDelegateBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> DelegateKey<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DelegateKey>>(UnregisterDelegate::VT_KEY, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for UnregisterDelegate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DelegateKey>>("key", Self::VT_KEY, true)?
     .finish();
    Ok(())
  }
}
pub struct UnregisterDelegateArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<DelegateKey<'a>>>,
}
impl<'a> Default for UnregisterDelegateArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnregisterDelegateArgs {
      key: None, // required field
    }
  }
}

pub struct UnregisterDelegateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnregisterDelegateBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<DelegateKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DelegateKey>>(UnregisterDelegate::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnregisterDelegateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnregisterDelegateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnregisterDelegate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, UnregisterDelegate::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnregisterDelegate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnregisterDelegate");
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum ContractRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContractRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContractRequest<'a> {
  type Inner = ContractRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContractRequest<'a> {
  pub const VT_CONTRACT_REQUEST_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CONTRACT_REQUEST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContractRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContractRequestArgs
  ) -> flatbuffers::WIPOffset<ContractRequest<'bldr>> {
    let mut builder = ContractRequestBuilder::new(_fbb);
    if let Some(x) = args.contract_request { builder.add_contract_request(x); }
    builder.add_contract_request_type(args.contract_request_type);
    builder.finish()
  }


  #[inline]
  pub fn contract_request_type(&self) -> ContractRequestType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ContractRequestType>(ContractRequest::VT_CONTRACT_REQUEST_TYPE, Some(ContractRequestType::NONE)).unwrap()}
  }
  #[inline]
  pub fn contract_request(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ContractRequest::VT_CONTRACT_REQUEST, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn contract_request_as_put(&self) -> Option<Put<'a>> {
    if self.contract_request_type() == ContractRequestType::Put {
      let u = self.contract_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Put::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contract_request_as_update(&self) -> Option<Update<'a>> {
    if self.contract_request_type() == ContractRequestType::Update {
      let u = self.contract_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Update::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contract_request_as_get(&self) -> Option<Get<'a>> {
    if self.contract_request_type() == ContractRequestType::Get {
      let u = self.contract_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Get::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contract_request_as_subscribe(&self) -> Option<Subscribe<'a>> {
    if self.contract_request_type() == ContractRequestType::Subscribe {
      let u = self.contract_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Subscribe::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ContractRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ContractRequestType, _>("contract_request_type", Self::VT_CONTRACT_REQUEST_TYPE, "contract_request", Self::VT_CONTRACT_REQUEST, true, |key, v, pos| {
        match key {
          ContractRequestType::Put => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Put>>("ContractRequestType::Put", pos),
          ContractRequestType::Update => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Update>>("ContractRequestType::Update", pos),
          ContractRequestType::Get => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Get>>("ContractRequestType::Get", pos),
          ContractRequestType::Subscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Subscribe>>("ContractRequestType::Subscribe", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ContractRequestArgs {
    pub contract_request_type: ContractRequestType,
    pub contract_request: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ContractRequestArgs {
  #[inline]
  fn default() -> Self {
    ContractRequestArgs {
      contract_request_type: ContractRequestType::NONE,
      contract_request: None, // required field
    }
  }
}

pub struct ContractRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContractRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_contract_request_type(&mut self, contract_request_type: ContractRequestType) {
    self.fbb_.push_slot::<ContractRequestType>(ContractRequest::VT_CONTRACT_REQUEST_TYPE, contract_request_type, ContractRequestType::NONE);
  }
  #[inline]
  pub fn add_contract_request(&mut self, contract_request: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContractRequest::VT_CONTRACT_REQUEST, contract_request);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContractRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContractRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContractRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContractRequest::VT_CONTRACT_REQUEST,"contract_request");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContractRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContractRequest");
      ds.field("contract_request_type", &self.contract_request_type());
      match self.contract_request_type() {
        ContractRequestType::Put => {
          if let Some(x) = self.contract_request_as_put() {
            ds.field("contract_request", &x)
          } else {
            ds.field("contract_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractRequestType::Update => {
          if let Some(x) = self.contract_request_as_update() {
            ds.field("contract_request", &x)
          } else {
            ds.field("contract_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractRequestType::Get => {
          if let Some(x) = self.contract_request_as_get() {
            ds.field("contract_request", &x)
          } else {
            ds.field("contract_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractRequestType::Subscribe => {
          if let Some(x) = self.contract_request_as_subscribe() {
            ds.field("contract_request", &x)
          } else {
            ds.field("contract_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("contract_request", &x)
        },
      };
      ds.finish()
  }
}
pub enum DelegateRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DelegateRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelegateRequest<'a> {
  type Inner = DelegateRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DelegateRequest<'a> {
  pub const VT_DELEGATE_REQUEST_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DELEGATE_REQUEST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DelegateRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DelegateRequestArgs
  ) -> flatbuffers::WIPOffset<DelegateRequest<'bldr>> {
    let mut builder = DelegateRequestBuilder::new(_fbb);
    if let Some(x) = args.delegate_request { builder.add_delegate_request(x); }
    builder.add_delegate_request_type(args.delegate_request_type);
    builder.finish()
  }


  #[inline]
  pub fn delegate_request_type(&self) -> DelegateRequestType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DelegateRequestType>(DelegateRequest::VT_DELEGATE_REQUEST_TYPE, Some(DelegateRequestType::NONE)).unwrap()}
  }
  #[inline]
  pub fn delegate_request(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DelegateRequest::VT_DELEGATE_REQUEST, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn delegate_request_as_application_messages(&self) -> Option<ApplicationMessages<'a>> {
    if self.delegate_request_type() == DelegateRequestType::ApplicationMessages {
      let u = self.delegate_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ApplicationMessages::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn delegate_request_as_get_secret_request_type(&self) -> Option<GetSecretRequestType<'a>> {
    if self.delegate_request_type() == DelegateRequestType::GetSecretRequestType {
      let u = self.delegate_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { GetSecretRequestType::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn delegate_request_as_register_delegate(&self) -> Option<RegisterDelegate<'a>> {
    if self.delegate_request_type() == DelegateRequestType::RegisterDelegate {
      let u = self.delegate_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { RegisterDelegate::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn delegate_request_as_unregister_delegate(&self) -> Option<UnregisterDelegate<'a>> {
    if self.delegate_request_type() == DelegateRequestType::UnregisterDelegate {
      let u = self.delegate_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { UnregisterDelegate::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DelegateRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<DelegateRequestType, _>("delegate_request_type", Self::VT_DELEGATE_REQUEST_TYPE, "delegate_request", Self::VT_DELEGATE_REQUEST, true, |key, v, pos| {
        match key {
          DelegateRequestType::ApplicationMessages => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ApplicationMessages>>("DelegateRequestType::ApplicationMessages", pos),
          DelegateRequestType::GetSecretRequestType => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetSecretRequestType>>("DelegateRequestType::GetSecretRequestType", pos),
          DelegateRequestType::RegisterDelegate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegisterDelegate>>("DelegateRequestType::RegisterDelegate", pos),
          DelegateRequestType::UnregisterDelegate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnregisterDelegate>>("DelegateRequestType::UnregisterDelegate", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct DelegateRequestArgs {
    pub delegate_request_type: DelegateRequestType,
    pub delegate_request: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DelegateRequestArgs {
  #[inline]
  fn default() -> Self {
    DelegateRequestArgs {
      delegate_request_type: DelegateRequestType::NONE,
      delegate_request: None, // required field
    }
  }
}

pub struct DelegateRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelegateRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_delegate_request_type(&mut self, delegate_request_type: DelegateRequestType) {
    self.fbb_.push_slot::<DelegateRequestType>(DelegateRequest::VT_DELEGATE_REQUEST_TYPE, delegate_request_type, DelegateRequestType::NONE);
  }
  #[inline]
  pub fn add_delegate_request(&mut self, delegate_request: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateRequest::VT_DELEGATE_REQUEST, delegate_request);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelegateRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DelegateRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DelegateRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DelegateRequest::VT_DELEGATE_REQUEST,"delegate_request");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DelegateRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DelegateRequest");
      ds.field("delegate_request_type", &self.delegate_request_type());
      match self.delegate_request_type() {
        DelegateRequestType::ApplicationMessages => {
          if let Some(x) = self.delegate_request_as_application_messages() {
            ds.field("delegate_request", &x)
          } else {
            ds.field("delegate_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        DelegateRequestType::GetSecretRequestType => {
          if let Some(x) = self.delegate_request_as_get_secret_request_type() {
            ds.field("delegate_request", &x)
          } else {
            ds.field("delegate_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        DelegateRequestType::RegisterDelegate => {
          if let Some(x) = self.delegate_request_as_register_delegate() {
            ds.field("delegate_request", &x)
          } else {
            ds.field("delegate_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        DelegateRequestType::UnregisterDelegate => {
          if let Some(x) = self.delegate_request_as_unregister_delegate() {
            ds.field("delegate_request", &x)
          } else {
            ds.field("delegate_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("delegate_request", &x)
        },
      };
      ds.finish()
  }
}
pub enum GenerateRandDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GenerateRandData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GenerateRandData<'a> {
  type Inner = GenerateRandData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GenerateRandData<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GenerateRandData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GenerateRandDataArgs
  ) -> flatbuffers::WIPOffset<GenerateRandData<'bldr>> {
    let mut builder = GenerateRandDataBuilder::new(_fbb);
    builder.add_data(args.data);
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GenerateRandData::VT_DATA, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GenerateRandData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct GenerateRandDataArgs {
    pub data: i32,
}
impl<'a> Default for GenerateRandDataArgs {
  #[inline]
  fn default() -> Self {
    GenerateRandDataArgs {
      data: 0,
    }
  }
}

pub struct GenerateRandDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GenerateRandDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: i32) {
    self.fbb_.push_slot::<i32>(GenerateRandData::VT_DATA, data, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GenerateRandDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GenerateRandDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GenerateRandData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GenerateRandData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GenerateRandData");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum DisconnectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Disconnect<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Disconnect<'a> {
  type Inner = Disconnect<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Disconnect<'a> {
  pub const VT_CAUSE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Disconnect { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DisconnectArgs<'args>
  ) -> flatbuffers::WIPOffset<Disconnect<'bldr>> {
    let mut builder = DisconnectBuilder::new(_fbb);
    if let Some(x) = args.cause { builder.add_cause(x); }
    builder.finish()
  }


  #[inline]
  pub fn cause(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Disconnect::VT_CAUSE, None)}
  }
}

impl flatbuffers::Verifiable for Disconnect<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cause", Self::VT_CAUSE, false)?
     .finish();
    Ok(())
  }
}
pub struct DisconnectArgs<'a> {
    pub cause: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DisconnectArgs<'a> {
  #[inline]
  fn default() -> Self {
    DisconnectArgs {
      cause: None,
    }
  }
}

pub struct DisconnectBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DisconnectBuilder<'a, 'b> {
  #[inline]
  pub fn add_cause(&mut self, cause: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Disconnect::VT_CAUSE, cause);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DisconnectBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DisconnectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Disconnect<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Disconnect<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Disconnect");
      ds.field("cause", &self.cause());
      ds.finish()
  }
}
pub enum ClientRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClientRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClientRequest<'a> {
  type Inner = ClientRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ClientRequest<'a> {
  pub const VT_CLIENT_REQUEST_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CLIENT_REQUEST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClientRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ClientRequestArgs
  ) -> flatbuffers::WIPOffset<ClientRequest<'bldr>> {
    let mut builder = ClientRequestBuilder::new(_fbb);
    if let Some(x) = args.client_request { builder.add_client_request(x); }
    builder.add_client_request_type(args.client_request_type);
    builder.finish()
  }


  #[inline]
  pub fn client_request_type(&self) -> ClientRequestType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ClientRequestType>(ClientRequest::VT_CLIENT_REQUEST_TYPE, Some(ClientRequestType::NONE)).unwrap()}
  }
  #[inline]
  pub fn client_request(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ClientRequest::VT_CLIENT_REQUEST, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn client_request_as_contract_request(&self) -> Option<ContractRequest<'a>> {
    if self.client_request_type() == ClientRequestType::ContractRequest {
      let u = self.client_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ContractRequest::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn client_request_as_delegate_request(&self) -> Option<DelegateRequest<'a>> {
    if self.client_request_type() == ClientRequestType::DelegateRequest {
      let u = self.client_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { DelegateRequest::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn client_request_as_generate_rand_data(&self) -> Option<GenerateRandData<'a>> {
    if self.client_request_type() == ClientRequestType::GenerateRandData {
      let u = self.client_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { GenerateRandData::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn client_request_as_disconnect(&self) -> Option<Disconnect<'a>> {
    if self.client_request_type() == ClientRequestType::Disconnect {
      let u = self.client_request();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Disconnect::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ClientRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ClientRequestType, _>("client_request_type", Self::VT_CLIENT_REQUEST_TYPE, "client_request", Self::VT_CLIENT_REQUEST, true, |key, v, pos| {
        match key {
          ClientRequestType::ContractRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ContractRequest>>("ClientRequestType::ContractRequest", pos),
          ClientRequestType::DelegateRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DelegateRequest>>("ClientRequestType::DelegateRequest", pos),
          ClientRequestType::GenerateRandData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GenerateRandData>>("ClientRequestType::GenerateRandData", pos),
          ClientRequestType::Disconnect => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Disconnect>>("ClientRequestType::Disconnect", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ClientRequestArgs {
    pub client_request_type: ClientRequestType,
    pub client_request: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ClientRequestArgs {
  #[inline]
  fn default() -> Self {
    ClientRequestArgs {
      client_request_type: ClientRequestType::NONE,
      client_request: None, // required field
    }
  }
}

pub struct ClientRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ClientRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_client_request_type(&mut self, client_request_type: ClientRequestType) {
    self.fbb_.push_slot::<ClientRequestType>(ClientRequest::VT_CLIENT_REQUEST_TYPE, client_request_type, ClientRequestType::NONE);
  }
  #[inline]
  pub fn add_client_request(&mut self, client_request: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientRequest::VT_CLIENT_REQUEST, client_request);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ClientRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ClientRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClientRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ClientRequest::VT_CLIENT_REQUEST,"client_request");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClientRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClientRequest");
      ds.field("client_request_type", &self.client_request_type());
      match self.client_request_type() {
        ClientRequestType::ContractRequest => {
          if let Some(x) = self.client_request_as_contract_request() {
            ds.field("client_request", &x)
          } else {
            ds.field("client_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ClientRequestType::DelegateRequest => {
          if let Some(x) = self.client_request_as_delegate_request() {
            ds.field("client_request", &x)
          } else {
            ds.field("client_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ClientRequestType::GenerateRandData => {
          if let Some(x) = self.client_request_as_generate_rand_data() {
            ds.field("client_request", &x)
          } else {
            ds.field("client_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ClientRequestType::Disconnect => {
          if let Some(x) = self.client_request_as_disconnect() {
            ds.field("client_request", &x)
          } else {
            ds.field("client_request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("client_request", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ClientRequest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_client_request_unchecked`.
pub fn root_as_client_request(buf: &[u8]) -> Result<ClientRequest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ClientRequest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ClientRequest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_client_request_unchecked`.
pub fn size_prefixed_root_as_client_request(buf: &[u8]) -> Result<ClientRequest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ClientRequest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ClientRequest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_client_request_unchecked`.
pub fn root_as_client_request_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ClientRequest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ClientRequest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ClientRequest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_client_request_unchecked`.
pub fn size_prefixed_root_as_client_request_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ClientRequest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ClientRequest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ClientRequest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ClientRequest`.
pub unsafe fn root_as_client_request_unchecked(buf: &[u8]) -> ClientRequest {
  flatbuffers::root_unchecked::<ClientRequest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ClientRequest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ClientRequest`.
pub unsafe fn size_prefixed_root_as_client_request_unchecked(buf: &[u8]) -> ClientRequest {
  flatbuffers::size_prefixed_root_unchecked::<ClientRequest>(buf)
}
#[inline]
pub fn finish_client_request_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ClientRequest<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_client_request_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ClientRequest<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod client_request

