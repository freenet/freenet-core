// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use crate::common_generated::*;
use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod host_response {

    use crate::common_generated::*;
    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_CONTRACT_RESPONSE_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_CONTRACT_RESPONSE_TYPE: u8 = 4;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_CONTRACT_RESPONSE_TYPE: [ContractResponseType; 5] = [
        ContractResponseType::NONE,
        ContractResponseType::GetResponse,
        ContractResponseType::PutResponse,
        ContractResponseType::UpdateNotification,
        ContractResponseType::UpdateResponse,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ContractResponseType(pub u8);
    #[allow(non_upper_case_globals)]
    impl ContractResponseType {
        pub const NONE: Self = Self(0);
        pub const GetResponse: Self = Self(1);
        pub const PutResponse: Self = Self(2);
        pub const UpdateNotification: Self = Self(3);
        pub const UpdateResponse: Self = Self(4);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 4;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::GetResponse,
            Self::PutResponse,
            Self::UpdateNotification,
            Self::UpdateResponse,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::GetResponse => Some("GetResponse"),
                Self::PutResponse => Some("PutResponse"),
                Self::UpdateNotification => Some("UpdateNotification"),
                Self::UpdateResponse => Some("UpdateResponse"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ContractResponseType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ContractResponseType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ContractResponseType {
        type Output = ContractResponseType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ContractResponseType {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ContractResponseType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ContractResponseType {}
    pub struct ContractResponseTypeUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_OUTBOUND_DELEGATE_MSG_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_OUTBOUND_DELEGATE_MSG_TYPE: u8 = 7;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_OUTBOUND_DELEGATE_MSG_TYPE: [OutboundDelegateMsgType; 8] = [
        OutboundDelegateMsgType::NONE,
        OutboundDelegateMsgType::common_ApplicationMessage,
        OutboundDelegateMsgType::RequestUserInput,
        OutboundDelegateMsgType::ContextUpdated,
        OutboundDelegateMsgType::common_GetSecretRequest,
        OutboundDelegateMsgType::SetSecretRequest,
        OutboundDelegateMsgType::RandomBytesRequest,
        OutboundDelegateMsgType::common_GetSecretResponse,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct OutboundDelegateMsgType(pub u8);
    #[allow(non_upper_case_globals)]
    impl OutboundDelegateMsgType {
        pub const NONE: Self = Self(0);
        pub const common_ApplicationMessage: Self = Self(1);
        pub const RequestUserInput: Self = Self(2);
        pub const ContextUpdated: Self = Self(3);
        pub const common_GetSecretRequest: Self = Self(4);
        pub const SetSecretRequest: Self = Self(5);
        pub const RandomBytesRequest: Self = Self(6);
        pub const common_GetSecretResponse: Self = Self(7);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 7;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::common_ApplicationMessage,
            Self::RequestUserInput,
            Self::ContextUpdated,
            Self::common_GetSecretRequest,
            Self::SetSecretRequest,
            Self::RandomBytesRequest,
            Self::common_GetSecretResponse,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::common_ApplicationMessage => Some("common_ApplicationMessage"),
                Self::RequestUserInput => Some("RequestUserInput"),
                Self::ContextUpdated => Some("ContextUpdated"),
                Self::common_GetSecretRequest => Some("common_GetSecretRequest"),
                Self::SetSecretRequest => Some("SetSecretRequest"),
                Self::RandomBytesRequest => Some("RandomBytesRequest"),
                Self::common_GetSecretResponse => Some("common_GetSecretResponse"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for OutboundDelegateMsgType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for OutboundDelegateMsgType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for OutboundDelegateMsgType {
        type Output = OutboundDelegateMsgType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for OutboundDelegateMsgType {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for OutboundDelegateMsgType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for OutboundDelegateMsgType {}
    pub struct OutboundDelegateMsgTypeUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_HOST_RESPONSE_TYPE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_HOST_RESPONSE_TYPE: u8 = 5;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_HOST_RESPONSE_TYPE: [HostResponseType; 6] = [
        HostResponseType::NONE,
        HostResponseType::ContractResponse,
        HostResponseType::DelegateResponse,
        HostResponseType::GenerateRandData,
        HostResponseType::Ok,
        HostResponseType::Error,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct HostResponseType(pub u8);
    #[allow(non_upper_case_globals)]
    impl HostResponseType {
        pub const NONE: Self = Self(0);
        pub const ContractResponse: Self = Self(1);
        pub const DelegateResponse: Self = Self(2);
        pub const GenerateRandData: Self = Self(3);
        pub const Ok: Self = Self(4);
        pub const Error: Self = Self(5);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 5;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::ContractResponse,
            Self::DelegateResponse,
            Self::GenerateRandData,
            Self::Ok,
            Self::Error,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::ContractResponse => Some("ContractResponse"),
                Self::DelegateResponse => Some("DelegateResponse"),
                Self::GenerateRandData => Some("GenerateRandData"),
                Self::Ok => Some("Ok"),
                Self::Error => Some("Error"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for HostResponseType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for HostResponseType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for HostResponseType {
        type Output = HostResponseType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for HostResponseType {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for HostResponseType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for HostResponseType {}
    pub struct HostResponseTypeUnionTableOffset {}

    pub enum GetResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GetResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GetResponse<'a> {
        type Inner = GetResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GetResponse<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_CONTRACT: flatbuffers::VOffsetT = 6;
        pub const VT_STATE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GetResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args GetResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<GetResponse<'bldr>> {
            let mut builder = GetResponseBuilder::new(_fbb);
            if let Some(x) = args.state {
                builder.add_state(x);
            }
            if let Some(x) = args.contract {
                builder.add_contract(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> super::common::ContractKey<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(
                        GetResponse::VT_KEY,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract(&self) -> Option<super::common::ContractContainer<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::common::ContractContainer>>(
                        GetResponse::VT_CONTRACT,
                        None,
                    )
            }
        }
        #[inline]
        pub fn state(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        GetResponse::VT_STATE,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for GetResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(
                    "key",
                    Self::VT_KEY,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractContainer>>(
                    "contract",
                    Self::VT_CONTRACT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "state",
                    Self::VT_STATE,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct GetResponseArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<super::common::ContractKey<'a>>>,
        pub contract: Option<flatbuffers::WIPOffset<super::common::ContractContainer<'a>>>,
        pub state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for GetResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            GetResponseArgs {
                key: None, // required field
                contract: None,
                state: None, // required field
            }
        }
    }

    pub struct GetResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> GetResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::ContractKey<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::common::ContractKey>>(
                    GetResponse::VT_KEY,
                    key,
                );
        }
        #[inline]
        pub fn add_contract(
            &mut self,
            contract: flatbuffers::WIPOffset<super::common::ContractContainer<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::common::ContractContainer>>(
                    GetResponse::VT_CONTRACT,
                    contract,
                );
        }
        #[inline]
        pub fn add_state(&mut self, state: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(GetResponse::VT_STATE, state);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            GetResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GetResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, GetResponse::VT_KEY, "key");
            self.fbb_.required(o, GetResponse::VT_STATE, "state");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GetResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GetResponse");
            ds.field("key", &self.key());
            ds.field("contract", &self.contract());
            ds.field("state", &self.state());
            ds.finish()
        }
    }
    pub enum PutResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PutResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PutResponse<'a> {
        type Inner = PutResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PutResponse<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PutResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PutResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<PutResponse<'bldr>> {
            let mut builder = PutResponseBuilder::new(_fbb);
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> super::common::ContractKey<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(
                        PutResponse::VT_KEY,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for PutResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(
                    "key",
                    Self::VT_KEY,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PutResponseArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<super::common::ContractKey<'a>>>,
    }
    impl<'a> Default for PutResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            PutResponseArgs {
                key: None, // required field
            }
        }
    }

    pub struct PutResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PutResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::ContractKey<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::common::ContractKey>>(
                    PutResponse::VT_KEY,
                    key,
                );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PutResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PutResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PutResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, PutResponse::VT_KEY, "key");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PutResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PutResponse");
            ds.field("key", &self.key());
            ds.finish()
        }
    }
    pub enum UpdateNotificationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdateNotification<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdateNotification<'a> {
        type Inner = UpdateNotification<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UpdateNotification<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdateNotification { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UpdateNotificationArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdateNotification<'bldr>> {
            let mut builder = UpdateNotificationBuilder::new(_fbb);
            if let Some(x) = args.update {
                builder.add_update(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> super::common::ContractKey<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(
                        UpdateNotification::VT_KEY,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn update(&self) -> super::common::UpdateData<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::common::UpdateData>>(
                        UpdateNotification::VT_UPDATE,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UpdateNotification<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(
                    "key",
                    Self::VT_KEY,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<super::common::UpdateData>>(
                    "update",
                    Self::VT_UPDATE,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UpdateNotificationArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<super::common::ContractKey<'a>>>,
        pub update: Option<flatbuffers::WIPOffset<super::common::UpdateData<'a>>>,
    }
    impl<'a> Default for UpdateNotificationArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdateNotificationArgs {
                key: None,    // required field
                update: None, // required field
            }
        }
    }

    pub struct UpdateNotificationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UpdateNotificationBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::ContractKey<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::common::ContractKey>>(
                    UpdateNotification::VT_KEY,
                    key,
                );
        }
        #[inline]
        pub fn add_update(
            &mut self,
            update: flatbuffers::WIPOffset<super::common::UpdateData<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::common::UpdateData>>(
                    UpdateNotification::VT_UPDATE,
                    update,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UpdateNotificationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UpdateNotificationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdateNotification<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, UpdateNotification::VT_KEY, "key");
            self.fbb_
                .required(o, UpdateNotification::VT_UPDATE, "update");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdateNotification<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdateNotification");
            ds.field("key", &self.key());
            ds.field("update", &self.update());
            ds.finish()
        }
    }
    pub enum UpdateResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdateResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdateResponse<'a> {
        type Inner = UpdateResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UpdateResponse<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_SUMMARY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdateResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UpdateResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdateResponse<'bldr>> {
            let mut builder = UpdateResponseBuilder::new(_fbb);
            if let Some(x) = args.summary {
                builder.add_summary(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> super::common::ContractKey<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(
                        UpdateResponse::VT_KEY,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn summary(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        UpdateResponse::VT_SUMMARY,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UpdateResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<super::common::ContractKey>>(
                    "key",
                    Self::VT_KEY,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "summary",
                    Self::VT_SUMMARY,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UpdateResponseArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<super::common::ContractKey<'a>>>,
        pub summary: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for UpdateResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdateResponseArgs {
                key: None,     // required field
                summary: None, // required field
            }
        }
    }

    pub struct UpdateResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UpdateResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::ContractKey<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::common::ContractKey>>(
                    UpdateResponse::VT_KEY,
                    key,
                );
        }
        #[inline]
        pub fn add_summary(
            &mut self,
            summary: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateResponse::VT_SUMMARY, summary);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UpdateResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UpdateResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdateResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, UpdateResponse::VT_KEY, "key");
            self.fbb_.required(o, UpdateResponse::VT_SUMMARY, "summary");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdateResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdateResponse");
            ds.field("key", &self.key());
            ds.field("summary", &self.summary());
            ds.finish()
        }
    }
    pub enum ContractResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ContractResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ContractResponse<'a> {
        type Inner = ContractResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ContractResponse<'a> {
        pub const VT_CONTRACT_RESPONSE_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_CONTRACT_RESPONSE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ContractResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ContractResponseArgs,
        ) -> flatbuffers::WIPOffset<ContractResponse<'bldr>> {
            let mut builder = ContractResponseBuilder::new(_fbb);
            if let Some(x) = args.contract_response {
                builder.add_contract_response(x);
            }
            builder.add_contract_response_type(args.contract_response_type);
            builder.finish()
        }

        #[inline]
        pub fn contract_response_type(&self) -> ContractResponseType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ContractResponseType>(
                        ContractResponse::VT_CONTRACT_RESPONSE_TYPE,
                        Some(ContractResponseType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn contract_response(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        ContractResponse::VT_CONTRACT_RESPONSE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn contract_response_as_get_response(&self) -> Option<GetResponse<'a>> {
            if self.contract_response_type() == ContractResponseType::GetResponse {
                let u = self.contract_response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { GetResponse::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn contract_response_as_put_response(&self) -> Option<PutResponse<'a>> {
            if self.contract_response_type() == ContractResponseType::PutResponse {
                let u = self.contract_response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { PutResponse::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn contract_response_as_update_notification(&self) -> Option<UpdateNotification<'a>> {
            if self.contract_response_type() == ContractResponseType::UpdateNotification {
                let u = self.contract_response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { UpdateNotification::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn contract_response_as_update_response(&self) -> Option<UpdateResponse<'a>> {
            if self.contract_response_type() == ContractResponseType::UpdateResponse {
                let u = self.contract_response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { UpdateResponse::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ContractResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<ContractResponseType, _>("contract_response_type", Self::VT_CONTRACT_RESPONSE_TYPE, "contract_response", Self::VT_CONTRACT_RESPONSE, true, |key, v, pos| {
        match key {
          ContractResponseType::GetResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetResponse>>("ContractResponseType::GetResponse", pos),
          ContractResponseType::PutResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PutResponse>>("ContractResponseType::PutResponse", pos),
          ContractResponseType::UpdateNotification => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpdateNotification>>("ContractResponseType::UpdateNotification", pos),
          ContractResponseType::UpdateResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpdateResponse>>("ContractResponseType::UpdateResponse", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ContractResponseArgs {
        pub contract_response_type: ContractResponseType,
        pub contract_response: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ContractResponseArgs {
        #[inline]
        fn default() -> Self {
            ContractResponseArgs {
                contract_response_type: ContractResponseType::NONE,
                contract_response: None, // required field
            }
        }
    }

    pub struct ContractResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ContractResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_contract_response_type(&mut self, contract_response_type: ContractResponseType) {
            self.fbb_.push_slot::<ContractResponseType>(
                ContractResponse::VT_CONTRACT_RESPONSE_TYPE,
                contract_response_type,
                ContractResponseType::NONE,
            );
        }
        #[inline]
        pub fn add_contract_response(
            &mut self,
            contract_response: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ContractResponse::VT_CONTRACT_RESPONSE,
                contract_response,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ContractResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ContractResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ContractResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(
                o,
                ContractResponse::VT_CONTRACT_RESPONSE,
                "contract_response",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ContractResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ContractResponse");
            ds.field("contract_response_type", &self.contract_response_type());
            match self.contract_response_type() {
                ContractResponseType::GetResponse => {
                    if let Some(x) = self.contract_response_as_get_response() {
                        ds.field("contract_response", &x)
                    } else {
                        ds.field(
                            "contract_response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractResponseType::PutResponse => {
                    if let Some(x) = self.contract_response_as_put_response() {
                        ds.field("contract_response", &x)
                    } else {
                        ds.field(
                            "contract_response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractResponseType::UpdateNotification => {
                    if let Some(x) = self.contract_response_as_update_notification() {
                        ds.field("contract_response", &x)
                    } else {
                        ds.field(
                            "contract_response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContractResponseType::UpdateResponse => {
                    if let Some(x) = self.contract_response_as_update_response() {
                        ds.field("contract_response", &x)
                    } else {
                        ds.field(
                            "contract_response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("contract_response", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum DelegateKeyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DelegateKey<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DelegateKey<'a> {
        type Inner = DelegateKey<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DelegateKey<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_CODE_HASH: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DelegateKey { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DelegateKeyArgs<'args>,
        ) -> flatbuffers::WIPOffset<DelegateKey<'bldr>> {
            let mut builder = DelegateKeyBuilder::new(_fbb);
            if let Some(x) = args.code_hash {
                builder.add_code_hash(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        DelegateKey::VT_KEY,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn code_hash(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        DelegateKey::VT_CODE_HASH,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DelegateKey<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "key",
                    Self::VT_KEY,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "code_hash",
                    Self::VT_CODE_HASH,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DelegateKeyArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub code_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for DelegateKeyArgs<'a> {
        #[inline]
        fn default() -> Self {
            DelegateKeyArgs {
                key: None,       // required field
                code_hash: None, // required field
            }
        }
    }

    pub struct DelegateKeyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DelegateKeyBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateKey::VT_KEY, key);
        }
        #[inline]
        pub fn add_code_hash(
            &mut self,
            code_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                DelegateKey::VT_CODE_HASH,
                code_hash,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelegateKeyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DelegateKeyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DelegateKey<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, DelegateKey::VT_KEY, "key");
            self.fbb_
                .required(o, DelegateKey::VT_CODE_HASH, "code_hash");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DelegateKey<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DelegateKey");
            ds.field("key", &self.key());
            ds.field("code_hash", &self.code_hash());
            ds.finish()
        }
    }
    pub enum UserInputRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UserInputRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UserInputRequest<'a> {
        type Inner = UserInputRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UserInputRequest<'a> {
        pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;
        pub const VT_RESPONSES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UserInputRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UserInputRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<UserInputRequest<'bldr>> {
            let mut builder = UserInputRequestBuilder::new(_fbb);
            if let Some(x) = args.responses {
                builder.add_responses(x);
            }
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            builder.add_request_id(args.request_id);
            builder.finish()
        }

        #[inline]
        pub fn request_id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(UserInputRequest::VT_REQUEST_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn message(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        UserInputRequest::VT_MESSAGE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn responses(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ClientResponse<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ClientResponse>>,
                    >>(UserInputRequest::VT_RESPONSES, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UserInputRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("request_id", Self::VT_REQUEST_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "message",
                    Self::VT_MESSAGE,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ClientResponse>>,
                >>("responses", Self::VT_RESPONSES, true)?
                .finish();
            Ok(())
        }
    }
    pub struct UserInputRequestArgs<'a> {
        pub request_id: u32,
        pub message: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub responses: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ClientResponse<'a>>>,
            >,
        >,
    }
    impl<'a> Default for UserInputRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            UserInputRequestArgs {
                request_id: 0,
                message: None,   // required field
                responses: None, // required field
            }
        }
    }

    pub struct UserInputRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UserInputRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_request_id(&mut self, request_id: u32) {
            self.fbb_
                .push_slot::<u32>(UserInputRequest::VT_REQUEST_ID, request_id, 0);
        }
        #[inline]
        pub fn add_message(
            &mut self,
            message: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UserInputRequest::VT_MESSAGE,
                message,
            );
        }
        #[inline]
        pub fn add_responses(
            &mut self,
            responses: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ClientResponse<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UserInputRequest::VT_RESPONSES,
                responses,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UserInputRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UserInputRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UserInputRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, UserInputRequest::VT_MESSAGE, "message");
            self.fbb_
                .required(o, UserInputRequest::VT_RESPONSES, "responses");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UserInputRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UserInputRequest");
            ds.field("request_id", &self.request_id());
            ds.field("message", &self.message());
            ds.field("responses", &self.responses());
            ds.finish()
        }
    }
    pub enum ClientResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ClientResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ClientResponse<'a> {
        type Inner = ClientResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ClientResponse<'a> {
        pub const VT_DATA: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ClientResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ClientResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<ClientResponse<'bldr>> {
            let mut builder = ClientResponseBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        ClientResponse::VT_DATA,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for ClientResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ClientResponseArgs<'a> {
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for ClientResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            ClientResponseArgs { data: None }
        }
    }

    pub struct ClientResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ClientResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ClientResponse::VT_DATA, data);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ClientResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ClientResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ClientResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ClientResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ClientResponse");
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    pub enum RequestUserInputOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RequestUserInput<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RequestUserInput<'a> {
        type Inner = RequestUserInput<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RequestUserInput<'a> {
        pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;
        pub const VT_RESPONSES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RequestUserInput { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RequestUserInputArgs<'args>,
        ) -> flatbuffers::WIPOffset<RequestUserInput<'bldr>> {
            let mut builder = RequestUserInputBuilder::new(_fbb);
            if let Some(x) = args.responses {
                builder.add_responses(x);
            }
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            builder.add_request_id(args.request_id);
            builder.finish()
        }

        #[inline]
        pub fn request_id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(RequestUserInput::VT_REQUEST_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn message(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        RequestUserInput::VT_MESSAGE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn responses(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ClientResponse<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ClientResponse>>,
                    >>(RequestUserInput::VT_RESPONSES, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for RequestUserInput<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("request_id", Self::VT_REQUEST_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "message",
                    Self::VT_MESSAGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ClientResponse>>,
                >>("responses", Self::VT_RESPONSES, true)?
                .finish();
            Ok(())
        }
    }
    pub struct RequestUserInputArgs<'a> {
        pub request_id: u32,
        pub message: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub responses: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ClientResponse<'a>>>,
            >,
        >,
    }
    impl<'a> Default for RequestUserInputArgs<'a> {
        #[inline]
        fn default() -> Self {
            RequestUserInputArgs {
                request_id: 0,
                message: None,
                responses: None, // required field
            }
        }
    }

    pub struct RequestUserInputBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RequestUserInputBuilder<'a, 'b> {
        #[inline]
        pub fn add_request_id(&mut self, request_id: u32) {
            self.fbb_
                .push_slot::<u32>(RequestUserInput::VT_REQUEST_ID, request_id, 0);
        }
        #[inline]
        pub fn add_message(
            &mut self,
            message: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RequestUserInput::VT_MESSAGE,
                message,
            );
        }
        #[inline]
        pub fn add_responses(
            &mut self,
            responses: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ClientResponse<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RequestUserInput::VT_RESPONSES,
                responses,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RequestUserInputBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RequestUserInputBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RequestUserInput<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, RequestUserInput::VT_RESPONSES, "responses");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RequestUserInput<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RequestUserInput");
            ds.field("request_id", &self.request_id());
            ds.field("message", &self.message());
            ds.field("responses", &self.responses());
            ds.finish()
        }
    }
    pub enum ContextUpdatedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ContextUpdated<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ContextUpdated<'a> {
        type Inner = ContextUpdated<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ContextUpdated<'a> {
        pub const VT_CONTEXT: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ContextUpdated { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ContextUpdatedArgs<'args>,
        ) -> flatbuffers::WIPOffset<ContextUpdated<'bldr>> {
            let mut builder = ContextUpdatedBuilder::new(_fbb);
            if let Some(x) = args.context {
                builder.add_context(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn context(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        ContextUpdated::VT_CONTEXT,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ContextUpdated<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "context",
                    Self::VT_CONTEXT,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ContextUpdatedArgs<'a> {
        pub context: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for ContextUpdatedArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContextUpdatedArgs {
                context: None, // required field
            }
        }
    }

    pub struct ContextUpdatedBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ContextUpdatedBuilder<'a, 'b> {
        #[inline]
        pub fn add_context(
            &mut self,
            context: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ContextUpdated::VT_CONTEXT, context);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ContextUpdatedBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ContextUpdatedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ContextUpdated<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ContextUpdated::VT_CONTEXT, "context");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ContextUpdated<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ContextUpdated");
            ds.field("context", &self.context());
            ds.finish()
        }
    }
    pub enum SetSecretRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SetSecretRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SetSecretRequest<'a> {
        type Inner = SetSecretRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SetSecretRequest<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SetSecretRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SetSecretRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<SetSecretRequest<'bldr>> {
            let mut builder = SetSecretRequestBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> super::common::SecretsId<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::common::SecretsId>>(
                        SetSecretRequest::VT_KEY,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SetSecretRequest::VT_VALUE,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SetSecretRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<super::common::SecretsId>>(
                    "key",
                    Self::VT_KEY,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SetSecretRequestArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<super::common::SecretsId<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for SetSecretRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            SetSecretRequestArgs {
                key: None,   // required field
                value: None, // required field
            }
        }
    }

    pub struct SetSecretRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SetSecretRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<super::common::SecretsId<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::common::SecretsId>>(
                    SetSecretRequest::VT_KEY,
                    key,
                );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SetSecretRequest::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SetSecretRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SetSecretRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SetSecretRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, SetSecretRequest::VT_KEY, "key");
            self.fbb_.required(o, SetSecretRequest::VT_VALUE, "value");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SetSecretRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SetSecretRequest");
            ds.field("key", &self.key());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum RandomBytesRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RandomBytesRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RandomBytesRequest<'a> {
        type Inner = RandomBytesRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RandomBytesRequest<'a> {
        pub const VT_DATA: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RandomBytesRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RandomBytesRequestArgs,
        ) -> flatbuffers::WIPOffset<RandomBytesRequest<'bldr>> {
            let mut builder = RandomBytesRequestBuilder::new(_fbb);
            builder.add_data(args.data);
            builder.finish()
        }

        #[inline]
        pub fn data(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(RandomBytesRequest::VT_DATA, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for RandomBytesRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("data", Self::VT_DATA, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RandomBytesRequestArgs {
        pub data: u32,
    }
    impl<'a> Default for RandomBytesRequestArgs {
        #[inline]
        fn default() -> Self {
            RandomBytesRequestArgs { data: 0 }
        }
    }

    pub struct RandomBytesRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RandomBytesRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_data(&mut self, data: u32) {
            self.fbb_
                .push_slot::<u32>(RandomBytesRequest::VT_DATA, data, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RandomBytesRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RandomBytesRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RandomBytesRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RandomBytesRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RandomBytesRequest");
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    pub enum OutboundDelegateMsgOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct OutboundDelegateMsg<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OutboundDelegateMsg<'a> {
        type Inner = OutboundDelegateMsg<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> OutboundDelegateMsg<'a> {
        pub const VT_INBOUND_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_INBOUND: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OutboundDelegateMsg { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OutboundDelegateMsgArgs,
        ) -> flatbuffers::WIPOffset<OutboundDelegateMsg<'bldr>> {
            let mut builder = OutboundDelegateMsgBuilder::new(_fbb);
            if let Some(x) = args.inbound {
                builder.add_inbound(x);
            }
            builder.add_inbound_type(args.inbound_type);
            builder.finish()
        }

        #[inline]
        pub fn inbound_type(&self) -> OutboundDelegateMsgType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<OutboundDelegateMsgType>(
                        OutboundDelegateMsg::VT_INBOUND_TYPE,
                        Some(OutboundDelegateMsgType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn inbound(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        OutboundDelegateMsg::VT_INBOUND,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn inbound_as_common_application_message(
            &self,
        ) -> Option<super::common::ApplicationMessage<'a>> {
            if self.inbound_type() == OutboundDelegateMsgType::common_ApplicationMessage {
                let u = self.inbound();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { super::common::ApplicationMessage::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn inbound_as_request_user_input(&self) -> Option<RequestUserInput<'a>> {
            if self.inbound_type() == OutboundDelegateMsgType::RequestUserInput {
                let u = self.inbound();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { RequestUserInput::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn inbound_as_context_updated(&self) -> Option<ContextUpdated<'a>> {
            if self.inbound_type() == OutboundDelegateMsgType::ContextUpdated {
                let u = self.inbound();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { ContextUpdated::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn inbound_as_common_get_secret_request(
            &self,
        ) -> Option<super::common::GetSecretRequest<'a>> {
            if self.inbound_type() == OutboundDelegateMsgType::common_GetSecretRequest {
                let u = self.inbound();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { super::common::GetSecretRequest::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn inbound_as_set_secret_request(&self) -> Option<SetSecretRequest<'a>> {
            if self.inbound_type() == OutboundDelegateMsgType::SetSecretRequest {
                let u = self.inbound();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { SetSecretRequest::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn inbound_as_random_bytes_request(&self) -> Option<RandomBytesRequest<'a>> {
            if self.inbound_type() == OutboundDelegateMsgType::RandomBytesRequest {
                let u = self.inbound();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { RandomBytesRequest::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn inbound_as_common_get_secret_response(
            &self,
        ) -> Option<super::common::GetSecretResponse<'a>> {
            if self.inbound_type() == OutboundDelegateMsgType::common_GetSecretResponse {
                let u = self.inbound();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { super::common::GetSecretResponse::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for OutboundDelegateMsg<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<OutboundDelegateMsgType, _>("inbound_type", Self::VT_INBOUND_TYPE, "inbound", Self::VT_INBOUND, true, |key, v, pos| {
        match key {
          OutboundDelegateMsgType::common_ApplicationMessage => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::common::ApplicationMessage>>("OutboundDelegateMsgType::common_ApplicationMessage", pos),
          OutboundDelegateMsgType::RequestUserInput => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RequestUserInput>>("OutboundDelegateMsgType::RequestUserInput", pos),
          OutboundDelegateMsgType::ContextUpdated => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ContextUpdated>>("OutboundDelegateMsgType::ContextUpdated", pos),
          OutboundDelegateMsgType::common_GetSecretRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::common::GetSecretRequest>>("OutboundDelegateMsgType::common_GetSecretRequest", pos),
          OutboundDelegateMsgType::SetSecretRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SetSecretRequest>>("OutboundDelegateMsgType::SetSecretRequest", pos),
          OutboundDelegateMsgType::RandomBytesRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RandomBytesRequest>>("OutboundDelegateMsgType::RandomBytesRequest", pos),
          OutboundDelegateMsgType::common_GetSecretResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::common::GetSecretResponse>>("OutboundDelegateMsgType::common_GetSecretResponse", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct OutboundDelegateMsgArgs {
        pub inbound_type: OutboundDelegateMsgType,
        pub inbound: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for OutboundDelegateMsgArgs {
        #[inline]
        fn default() -> Self {
            OutboundDelegateMsgArgs {
                inbound_type: OutboundDelegateMsgType::NONE,
                inbound: None, // required field
            }
        }
    }

    pub struct OutboundDelegateMsgBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OutboundDelegateMsgBuilder<'a, 'b> {
        #[inline]
        pub fn add_inbound_type(&mut self, inbound_type: OutboundDelegateMsgType) {
            self.fbb_.push_slot::<OutboundDelegateMsgType>(
                OutboundDelegateMsg::VT_INBOUND_TYPE,
                inbound_type,
                OutboundDelegateMsgType::NONE,
            );
        }
        #[inline]
        pub fn add_inbound(
            &mut self,
            inbound: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                OutboundDelegateMsg::VT_INBOUND,
                inbound,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> OutboundDelegateMsgBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OutboundDelegateMsgBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OutboundDelegateMsg<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, OutboundDelegateMsg::VT_INBOUND, "inbound");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for OutboundDelegateMsg<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("OutboundDelegateMsg");
            ds.field("inbound_type", &self.inbound_type());
            match self.inbound_type() {
                OutboundDelegateMsgType::common_ApplicationMessage => {
                    if let Some(x) = self.inbound_as_common_application_message() {
                        ds.field("inbound", &x)
                    } else {
                        ds.field(
                            "inbound",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                OutboundDelegateMsgType::RequestUserInput => {
                    if let Some(x) = self.inbound_as_request_user_input() {
                        ds.field("inbound", &x)
                    } else {
                        ds.field(
                            "inbound",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                OutboundDelegateMsgType::ContextUpdated => {
                    if let Some(x) = self.inbound_as_context_updated() {
                        ds.field("inbound", &x)
                    } else {
                        ds.field(
                            "inbound",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                OutboundDelegateMsgType::common_GetSecretRequest => {
                    if let Some(x) = self.inbound_as_common_get_secret_request() {
                        ds.field("inbound", &x)
                    } else {
                        ds.field(
                            "inbound",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                OutboundDelegateMsgType::SetSecretRequest => {
                    if let Some(x) = self.inbound_as_set_secret_request() {
                        ds.field("inbound", &x)
                    } else {
                        ds.field(
                            "inbound",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                OutboundDelegateMsgType::RandomBytesRequest => {
                    if let Some(x) = self.inbound_as_random_bytes_request() {
                        ds.field("inbound", &x)
                    } else {
                        ds.field(
                            "inbound",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                OutboundDelegateMsgType::common_GetSecretResponse => {
                    if let Some(x) = self.inbound_as_common_get_secret_response() {
                        ds.field("inbound", &x)
                    } else {
                        ds.field(
                            "inbound",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("inbound", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum DelegateResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DelegateResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DelegateResponse<'a> {
        type Inner = DelegateResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DelegateResponse<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_VALUES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DelegateResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DelegateResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<DelegateResponse<'bldr>> {
            let mut builder = DelegateResponseBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> DelegateKey<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DelegateKey>>(
                        DelegateResponse::VT_KEY,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn values(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutboundDelegateMsg<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutboundDelegateMsg>>,
                    >>(DelegateResponse::VT_VALUES, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DelegateResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<DelegateKey>>(
                    "key",
                    Self::VT_KEY,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OutboundDelegateMsg>>,
                >>("values", Self::VT_VALUES, true)?
                .finish();
            Ok(())
        }
    }
    pub struct DelegateResponseArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<DelegateKey<'a>>>,
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutboundDelegateMsg<'a>>>,
            >,
        >,
    }
    impl<'a> Default for DelegateResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            DelegateResponseArgs {
                key: None,    // required field
                values: None, // required field
            }
        }
    }

    pub struct DelegateResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DelegateResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<DelegateKey<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<DelegateKey>>(
                    DelegateResponse::VT_KEY,
                    key,
                );
        }
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<OutboundDelegateMsg<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DelegateResponse::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DelegateResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DelegateResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DelegateResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, DelegateResponse::VT_KEY, "key");
            self.fbb_.required(o, DelegateResponse::VT_VALUES, "values");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DelegateResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DelegateResponse");
            ds.field("key", &self.key());
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    pub enum GenerateRandDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GenerateRandData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GenerateRandData<'a> {
        type Inner = GenerateRandData<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GenerateRandData<'a> {
        pub const VT_WRAPPED_STATE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GenerateRandData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args GenerateRandDataArgs<'args>,
        ) -> flatbuffers::WIPOffset<GenerateRandData<'bldr>> {
            let mut builder = GenerateRandDataBuilder::new(_fbb);
            if let Some(x) = args.wrapped_state {
                builder.add_wrapped_state(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn wrapped_state(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        GenerateRandData::VT_WRAPPED_STATE,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for GenerateRandData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "wrapped_state",
                    Self::VT_WRAPPED_STATE,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct GenerateRandDataArgs<'a> {
        pub wrapped_state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for GenerateRandDataArgs<'a> {
        #[inline]
        fn default() -> Self {
            GenerateRandDataArgs {
                wrapped_state: None, // required field
            }
        }
    }

    pub struct GenerateRandDataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> GenerateRandDataBuilder<'a, 'b> {
        #[inline]
        pub fn add_wrapped_state(
            &mut self,
            wrapped_state: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                GenerateRandData::VT_WRAPPED_STATE,
                wrapped_state,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> GenerateRandDataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            GenerateRandDataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GenerateRandData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, GenerateRandData::VT_WRAPPED_STATE, "wrapped_state");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GenerateRandData<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GenerateRandData");
            ds.field("wrapped_state", &self.wrapped_state());
            ds.finish()
        }
    }
    pub enum OkOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Ok<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Ok<'a> {
        type Inner = Ok<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Ok<'a> {
        pub const VT_MSG: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Ok { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OkArgs<'args>,
        ) -> flatbuffers::WIPOffset<Ok<'bldr>> {
            let mut builder = OkBuilder::new(_fbb);
            if let Some(x) = args.msg {
                builder.add_msg(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn msg(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Ok::VT_MSG, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Ok<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msg", Self::VT_MSG, true)?
                .finish();
            Ok(())
        }
    }
    pub struct OkArgs<'a> {
        pub msg: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for OkArgs<'a> {
        #[inline]
        fn default() -> Self {
            OkArgs {
                msg: None, // required field
            }
        }
    }

    pub struct OkBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OkBuilder<'a, 'b> {
        #[inline]
        pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Ok::VT_MSG, msg);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OkBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OkBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Ok<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Ok::VT_MSG, "msg");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Ok<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Ok");
            ds.field("msg", &self.msg());
            ds.finish()
        }
    }
    pub enum ErrorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Error<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Error<'a> {
        type Inner = Error<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Error<'a> {
        pub const VT_MSG: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Error { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ErrorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Error<'bldr>> {
            let mut builder = ErrorBuilder::new(_fbb);
            if let Some(x) = args.msg {
                builder.add_msg(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn msg(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_MSG, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Error<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msg", Self::VT_MSG, true)?
                .finish();
            Ok(())
        }
    }
    pub struct ErrorArgs<'a> {
        pub msg: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ErrorArgs<'a> {
        #[inline]
        fn default() -> Self {
            ErrorArgs {
                msg: None, // required field
            }
        }
    }

    pub struct ErrorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ErrorBuilder<'a, 'b> {
        #[inline]
        pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_MSG, msg);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ErrorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ErrorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Error::VT_MSG, "msg");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Error<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Error");
            ds.field("msg", &self.msg());
            ds.finish()
        }
    }
    pub enum HostResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct HostResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for HostResponse<'a> {
        type Inner = HostResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> HostResponse<'a> {
        pub const VT_RESPONSE_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_RESPONSE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            HostResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args HostResponseArgs,
        ) -> flatbuffers::WIPOffset<HostResponse<'bldr>> {
            let mut builder = HostResponseBuilder::new(_fbb);
            if let Some(x) = args.response {
                builder.add_response(x);
            }
            builder.add_response_type(args.response_type);
            builder.finish()
        }

        #[inline]
        pub fn response_type(&self) -> HostResponseType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<HostResponseType>(
                        HostResponse::VT_RESPONSE_TYPE,
                        Some(HostResponseType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn response(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        HostResponse::VT_RESPONSE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn response_as_contract_response(&self) -> Option<ContractResponse<'a>> {
            if self.response_type() == HostResponseType::ContractResponse {
                let u = self.response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { ContractResponse::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn response_as_delegate_response(&self) -> Option<DelegateResponse<'a>> {
            if self.response_type() == HostResponseType::DelegateResponse {
                let u = self.response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { DelegateResponse::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn response_as_generate_rand_data(&self) -> Option<GenerateRandData<'a>> {
            if self.response_type() == HostResponseType::GenerateRandData {
                let u = self.response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { GenerateRandData::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn response_as_ok(&self) -> Option<Ok<'a>> {
            if self.response_type() == HostResponseType::Ok {
                let u = self.response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { Ok::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn response_as_error(&self) -> Option<Error<'a>> {
            if self.response_type() == HostResponseType::Error {
                let u = self.response();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { Error::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for HostResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<HostResponseType, _>(
                    "response_type",
                    Self::VT_RESPONSE_TYPE,
                    "response",
                    Self::VT_RESPONSE,
                    true,
                    |key, v, pos| match key {
                        HostResponseType::ContractResponse => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<ContractResponse>>(
                                "HostResponseType::ContractResponse",
                                pos,
                            ),
                        HostResponseType::DelegateResponse => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<DelegateResponse>>(
                                "HostResponseType::DelegateResponse",
                                pos,
                            ),
                        HostResponseType::GenerateRandData => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<GenerateRandData>>(
                                "HostResponseType::GenerateRandData",
                                pos,
                            ),
                        HostResponseType::Ok => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Ok>>(
                                "HostResponseType::Ok",
                                pos,
                            ),
                        HostResponseType::Error => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>(
                                "HostResponseType::Error",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct HostResponseArgs {
        pub response_type: HostResponseType,
        pub response: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for HostResponseArgs {
        #[inline]
        fn default() -> Self {
            HostResponseArgs {
                response_type: HostResponseType::NONE,
                response: None, // required field
            }
        }
    }

    pub struct HostResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HostResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_response_type(&mut self, response_type: HostResponseType) {
            self.fbb_.push_slot::<HostResponseType>(
                HostResponse::VT_RESPONSE_TYPE,
                response_type,
                HostResponseType::NONE,
            );
        }
        #[inline]
        pub fn add_response(
            &mut self,
            response: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(HostResponse::VT_RESPONSE, response);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> HostResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HostResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<HostResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, HostResponse::VT_RESPONSE, "response");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for HostResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("HostResponse");
            ds.field("response_type", &self.response_type());
            match self.response_type() {
                HostResponseType::ContractResponse => {
                    if let Some(x) = self.response_as_contract_response() {
                        ds.field("response", &x)
                    } else {
                        ds.field(
                            "response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                HostResponseType::DelegateResponse => {
                    if let Some(x) = self.response_as_delegate_response() {
                        ds.field("response", &x)
                    } else {
                        ds.field(
                            "response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                HostResponseType::GenerateRandData => {
                    if let Some(x) = self.response_as_generate_rand_data() {
                        ds.field("response", &x)
                    } else {
                        ds.field(
                            "response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                HostResponseType::Ok => {
                    if let Some(x) = self.response_as_ok() {
                        ds.field("response", &x)
                    } else {
                        ds.field(
                            "response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                HostResponseType::Error => {
                    if let Some(x) = self.response_as_error() {
                        ds.field("response", &x)
                    } else {
                        ds.field(
                            "response",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("response", &x)
                }
            };
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `HostResponse`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_host_response_unchecked`.
    pub fn root_as_host_response(
        buf: &[u8],
    ) -> Result<HostResponse, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<HostResponse>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `HostResponse` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_host_response_unchecked`.
    pub fn size_prefixed_root_as_host_response(
        buf: &[u8],
    ) -> Result<HostResponse, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<HostResponse>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `HostResponse` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_host_response_unchecked`.
    pub fn root_as_host_response_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<HostResponse<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<HostResponse<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `HostResponse` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_host_response_unchecked`.
    pub fn size_prefixed_root_as_host_response_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<HostResponse<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<HostResponse<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a HostResponse and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `HostResponse`.
    pub unsafe fn root_as_host_response_unchecked(buf: &[u8]) -> HostResponse {
        flatbuffers::root_unchecked::<HostResponse>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed HostResponse and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `HostResponse`.
    pub unsafe fn size_prefixed_root_as_host_response_unchecked(buf: &[u8]) -> HostResponse {
        flatbuffers::size_prefixed_root_unchecked::<HostResponse>(buf)
    }
    #[inline]
    pub fn finish_host_response_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<HostResponse<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_host_response_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<HostResponse<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod host_response
