// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod common {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTRACT_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTRACT_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTRACT_TYPE: [ContractType; 2] = [
  ContractType::NONE,
  ContractType::WasmContractV1,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ContractType(pub u8);
#[allow(non_upper_case_globals)]
impl ContractType {
  pub const NONE: Self = Self(0);
  pub const WasmContractV1: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::WasmContractV1,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::WasmContractV1 => Some("WasmContractV1"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ContractType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ContractType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ContractType {
    type Output = ContractType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ContractType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ContractType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ContractType {}
pub struct ContractTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_UPDATE_DATA_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_UPDATE_DATA_TYPE: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_UPDATE_DATA_TYPE: [UpdateDataType; 7] = [
  UpdateDataType::NONE,
  UpdateDataType::StateUpdate,
  UpdateDataType::DeltaUpdate,
  UpdateDataType::StateAndDeltaUpdate,
  UpdateDataType::RelatedStateUpdate,
  UpdateDataType::RelatedDeltaUpdate,
  UpdateDataType::RelatedStateAndDeltaUpdate,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct UpdateDataType(pub u8);
#[allow(non_upper_case_globals)]
impl UpdateDataType {
  pub const NONE: Self = Self(0);
  pub const StateUpdate: Self = Self(1);
  pub const DeltaUpdate: Self = Self(2);
  pub const StateAndDeltaUpdate: Self = Self(3);
  pub const RelatedStateUpdate: Self = Self(4);
  pub const RelatedDeltaUpdate: Self = Self(5);
  pub const RelatedStateAndDeltaUpdate: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::StateUpdate,
    Self::DeltaUpdate,
    Self::StateAndDeltaUpdate,
    Self::RelatedStateUpdate,
    Self::RelatedDeltaUpdate,
    Self::RelatedStateAndDeltaUpdate,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::StateUpdate => Some("StateUpdate"),
      Self::DeltaUpdate => Some("DeltaUpdate"),
      Self::StateAndDeltaUpdate => Some("StateAndDeltaUpdate"),
      Self::RelatedStateUpdate => Some("RelatedStateUpdate"),
      Self::RelatedDeltaUpdate => Some("RelatedDeltaUpdate"),
      Self::RelatedStateAndDeltaUpdate => Some("RelatedStateAndDeltaUpdate"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for UpdateDataType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for UpdateDataType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for UpdateDataType {
    type Output = UpdateDataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for UpdateDataType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for UpdateDataType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for UpdateDataType {}
pub struct UpdateDataTypeUnionTableOffset {}

pub enum ContractInstanceIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContractInstanceId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContractInstanceId<'a> {
  type Inner = ContractInstanceId<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContractInstanceId<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContractInstanceId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContractInstanceIdArgs<'args>
  ) -> flatbuffers::WIPOffset<ContractInstanceId<'bldr>> {
    let mut builder = ContractInstanceIdBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ContractInstanceId::VT_DATA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ContractInstanceId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, true)?
     .finish();
    Ok(())
  }
}
pub struct ContractInstanceIdArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ContractInstanceIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContractInstanceIdArgs {
      data: None, // required field
    }
  }
}

pub struct ContractInstanceIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContractInstanceIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContractInstanceId::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContractInstanceIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContractInstanceIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContractInstanceId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContractInstanceId::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContractInstanceId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContractInstanceId");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum ContractKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContractKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContractKey<'a> {
  type Inner = ContractKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContractKey<'a> {
  pub const VT_INSTANCE: flatbuffers::VOffsetT = 4;
  pub const VT_CODE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContractKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContractKeyArgs<'args>
  ) -> flatbuffers::WIPOffset<ContractKey<'bldr>> {
    let mut builder = ContractKeyBuilder::new(_fbb);
    if let Some(x) = args.code { builder.add_code(x); }
    if let Some(x) = args.instance { builder.add_instance(x); }
    builder.finish()
  }


  #[inline]
  pub fn instance(&self) -> ContractInstanceId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContractInstanceId>>(ContractKey::VT_INSTANCE, None).unwrap()}
  }
  #[inline]
  pub fn code(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ContractKey::VT_CODE, None)}
  }
}

impl flatbuffers::Verifiable for ContractKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContractInstanceId>>("instance", Self::VT_INSTANCE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("code", Self::VT_CODE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContractKeyArgs<'a> {
    pub instance: Option<flatbuffers::WIPOffset<ContractInstanceId<'a>>>,
    pub code: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ContractKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContractKeyArgs {
      instance: None, // required field
      code: None,
    }
  }
}

pub struct ContractKeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContractKeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_instance(&mut self, instance: flatbuffers::WIPOffset<ContractInstanceId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContractInstanceId>>(ContractKey::VT_INSTANCE, instance);
  }
  #[inline]
  pub fn add_code(&mut self, code: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContractKey::VT_CODE, code);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContractKeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContractKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContractKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContractKey::VT_INSTANCE,"instance");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContractKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContractKey");
      ds.field("instance", &self.instance());
      ds.field("code", &self.code());
      ds.finish()
  }
}
pub enum SecretsIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SecretsId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SecretsId<'a> {
  type Inner = SecretsId<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SecretsId<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_HASH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SecretsId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SecretsIdArgs<'args>
  ) -> flatbuffers::WIPOffset<SecretsId<'bldr>> {
    let mut builder = SecretsIdBuilder::new(_fbb);
    if let Some(x) = args.hash { builder.add_hash(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SecretsId::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn hash(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SecretsId::VT_HASH, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for SecretsId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("hash", Self::VT_HASH, true)?
     .finish();
    Ok(())
  }
}
pub struct SecretsIdArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SecretsIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    SecretsIdArgs {
      key: None, // required field
      hash: None, // required field
    }
  }
}

pub struct SecretsIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SecretsIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SecretsId::VT_KEY, key);
  }
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SecretsId::VT_HASH, hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SecretsIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SecretsIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SecretsId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SecretsId::VT_KEY,"key");
    self.fbb_.required(o, SecretsId::VT_HASH,"hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SecretsId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SecretsId");
      ds.field("key", &self.key());
      ds.field("hash", &self.hash());
      ds.finish()
  }
}
pub enum ContractCodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContractCode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContractCode<'a> {
  type Inner = ContractCode<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContractCode<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_CODE_HASH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContractCode { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContractCodeArgs<'args>
  ) -> flatbuffers::WIPOffset<ContractCode<'bldr>> {
    let mut builder = ContractCodeBuilder::new(_fbb);
    if let Some(x) = args.code_hash { builder.add_code_hash(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ContractCode::VT_DATA, None).unwrap()}
  }
  #[inline]
  pub fn code_hash(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ContractCode::VT_CODE_HASH, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ContractCode<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("code_hash", Self::VT_CODE_HASH, true)?
     .finish();
    Ok(())
  }
}
pub struct ContractCodeArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub code_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ContractCodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContractCodeArgs {
      data: None, // required field
      code_hash: None, // required field
    }
  }
}

pub struct ContractCodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContractCodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContractCode::VT_DATA, data);
  }
  #[inline]
  pub fn add_code_hash(&mut self, code_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContractCode::VT_CODE_HASH, code_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContractCodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContractCodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContractCode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContractCode::VT_DATA,"data");
    self.fbb_.required(o, ContractCode::VT_CODE_HASH,"code_hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContractCode<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContractCode");
      ds.field("data", &self.data());
      ds.field("code_hash", &self.code_hash());
      ds.finish()
  }
}
pub enum WasmContractV1Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WasmContractV1<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WasmContractV1<'a> {
  type Inner = WasmContractV1<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WasmContractV1<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMETERS: flatbuffers::VOffsetT = 6;
  pub const VT_KEY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WasmContractV1 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WasmContractV1Args<'args>
  ) -> flatbuffers::WIPOffset<WasmContractV1<'bldr>> {
    let mut builder = WasmContractV1Builder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.parameters { builder.add_parameters(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> ContractCode<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContractCode>>(WasmContractV1::VT_DATA, None).unwrap()}
  }
  #[inline]
  pub fn parameters(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(WasmContractV1::VT_PARAMETERS, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> ContractKey<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContractKey>>(WasmContractV1::VT_KEY, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for WasmContractV1<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContractCode>>("data", Self::VT_DATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("parameters", Self::VT_PARAMETERS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContractKey>>("key", Self::VT_KEY, true)?
     .finish();
    Ok(())
  }
}
pub struct WasmContractV1Args<'a> {
    pub data: Option<flatbuffers::WIPOffset<ContractCode<'a>>>,
    pub parameters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub key: Option<flatbuffers::WIPOffset<ContractKey<'a>>>,
}
impl<'a> Default for WasmContractV1Args<'a> {
  #[inline]
  fn default() -> Self {
    WasmContractV1Args {
      data: None, // required field
      parameters: None, // required field
      key: None, // required field
    }
  }
}

pub struct WasmContractV1Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WasmContractV1Builder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<ContractCode<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContractCode>>(WasmContractV1::VT_DATA, data);
  }
  #[inline]
  pub fn add_parameters(&mut self, parameters: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WasmContractV1::VT_PARAMETERS, parameters);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<ContractKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContractKey>>(WasmContractV1::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WasmContractV1Builder<'a, 'b> {
    let start = _fbb.start_table();
    WasmContractV1Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WasmContractV1<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WasmContractV1::VT_DATA,"data");
    self.fbb_.required(o, WasmContractV1::VT_PARAMETERS,"parameters");
    self.fbb_.required(o, WasmContractV1::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WasmContractV1<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WasmContractV1");
      ds.field("data", &self.data());
      ds.field("parameters", &self.parameters());
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum ContractContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContractContainer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContractContainer<'a> {
  type Inner = ContractContainer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContractContainer<'a> {
  pub const VT_CONTRACT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CONTRACT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContractContainer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContractContainerArgs
  ) -> flatbuffers::WIPOffset<ContractContainer<'bldr>> {
    let mut builder = ContractContainerBuilder::new(_fbb);
    if let Some(x) = args.contract { builder.add_contract(x); }
    builder.add_contract_type(args.contract_type);
    builder.finish()
  }


  #[inline]
  pub fn contract_type(&self) -> ContractType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ContractType>(ContractContainer::VT_CONTRACT_TYPE, Some(ContractType::NONE)).unwrap()}
  }
  #[inline]
  pub fn contract(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ContractContainer::VT_CONTRACT, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn contract_as_wasm_contract_v1(&self) -> Option<WasmContractV1<'a>> {
    if self.contract_type() == ContractType::WasmContractV1 {
      let u = self.contract();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { WasmContractV1::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ContractContainer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ContractType, _>("contract_type", Self::VT_CONTRACT_TYPE, "contract", Self::VT_CONTRACT, true, |key, v, pos| {
        match key {
          ContractType::WasmContractV1 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WasmContractV1>>("ContractType::WasmContractV1", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ContractContainerArgs {
    pub contract_type: ContractType,
    pub contract: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ContractContainerArgs {
  #[inline]
  fn default() -> Self {
    ContractContainerArgs {
      contract_type: ContractType::NONE,
      contract: None, // required field
    }
  }
}

pub struct ContractContainerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContractContainerBuilder<'a, 'b> {
  #[inline]
  pub fn add_contract_type(&mut self, contract_type: ContractType) {
    self.fbb_.push_slot::<ContractType>(ContractContainer::VT_CONTRACT_TYPE, contract_type, ContractType::NONE);
  }
  #[inline]
  pub fn add_contract(&mut self, contract: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContractContainer::VT_CONTRACT, contract);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContractContainerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContractContainerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContractContainer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContractContainer::VT_CONTRACT,"contract");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContractContainer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContractContainer");
      ds.field("contract_type", &self.contract_type());
      match self.contract_type() {
        ContractType::WasmContractV1 => {
          if let Some(x) = self.contract_as_wasm_contract_v1() {
            ds.field("contract", &x)
          } else {
            ds.field("contract", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("contract", &x)
        },
      };
      ds.finish()
  }
}
pub enum StateUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StateUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StateUpdate<'a> {
  type Inner = StateUpdate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StateUpdate<'a> {
  pub const VT_STATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StateUpdate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StateUpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<StateUpdate<'bldr>> {
    let mut builder = StateUpdateBuilder::new(_fbb);
    if let Some(x) = args.state { builder.add_state(x); }
    builder.finish()
  }


  #[inline]
  pub fn state(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(StateUpdate::VT_STATE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for StateUpdate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("state", Self::VT_STATE, true)?
     .finish();
    Ok(())
  }
}
pub struct StateUpdateArgs<'a> {
    pub state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for StateUpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    StateUpdateArgs {
      state: None, // required field
    }
  }
}

pub struct StateUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StateUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateUpdate::VT_STATE, state);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StateUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StateUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StateUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, StateUpdate::VT_STATE,"state");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StateUpdate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StateUpdate");
      ds.field("state", &self.state());
      ds.finish()
  }
}
pub enum DeltaUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeltaUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeltaUpdate<'a> {
  type Inner = DeltaUpdate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DeltaUpdate<'a> {
  pub const VT_DELTA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DeltaUpdate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DeltaUpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<DeltaUpdate<'bldr>> {
    let mut builder = DeltaUpdateBuilder::new(_fbb);
    if let Some(x) = args.delta { builder.add_delta(x); }
    builder.finish()
  }


  #[inline]
  pub fn delta(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DeltaUpdate::VT_DELTA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for DeltaUpdate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("delta", Self::VT_DELTA, true)?
     .finish();
    Ok(())
  }
}
pub struct DeltaUpdateArgs<'a> {
    pub delta: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DeltaUpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    DeltaUpdateArgs {
      delta: None, // required field
    }
  }
}

pub struct DeltaUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeltaUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_delta(&mut self, delta: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeltaUpdate::VT_DELTA, delta);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeltaUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DeltaUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeltaUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DeltaUpdate::VT_DELTA,"delta");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DeltaUpdate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DeltaUpdate");
      ds.field("delta", &self.delta());
      ds.finish()
  }
}
pub enum StateAndDeltaUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StateAndDeltaUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StateAndDeltaUpdate<'a> {
  type Inner = StateAndDeltaUpdate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StateAndDeltaUpdate<'a> {
  pub const VT_STATE: flatbuffers::VOffsetT = 4;
  pub const VT_DELTA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StateAndDeltaUpdate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StateAndDeltaUpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<StateAndDeltaUpdate<'bldr>> {
    let mut builder = StateAndDeltaUpdateBuilder::new(_fbb);
    if let Some(x) = args.delta { builder.add_delta(x); }
    if let Some(x) = args.state { builder.add_state(x); }
    builder.finish()
  }


  #[inline]
  pub fn state(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(StateAndDeltaUpdate::VT_STATE, None).unwrap()}
  }
  #[inline]
  pub fn delta(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(StateAndDeltaUpdate::VT_DELTA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for StateAndDeltaUpdate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("state", Self::VT_STATE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("delta", Self::VT_DELTA, true)?
     .finish();
    Ok(())
  }
}
pub struct StateAndDeltaUpdateArgs<'a> {
    pub state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub delta: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for StateAndDeltaUpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    StateAndDeltaUpdateArgs {
      state: None, // required field
      delta: None, // required field
    }
  }
}

pub struct StateAndDeltaUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StateAndDeltaUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateAndDeltaUpdate::VT_STATE, state);
  }
  #[inline]
  pub fn add_delta(&mut self, delta: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateAndDeltaUpdate::VT_DELTA, delta);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StateAndDeltaUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StateAndDeltaUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StateAndDeltaUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, StateAndDeltaUpdate::VT_STATE,"state");
    self.fbb_.required(o, StateAndDeltaUpdate::VT_DELTA,"delta");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StateAndDeltaUpdate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StateAndDeltaUpdate");
      ds.field("state", &self.state());
      ds.field("delta", &self.delta());
      ds.finish()
  }
}
pub enum RelatedStateUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelatedStateUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelatedStateUpdate<'a> {
  type Inner = RelatedStateUpdate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelatedStateUpdate<'a> {
  pub const VT_RELATED_TO: flatbuffers::VOffsetT = 4;
  pub const VT_STATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelatedStateUpdate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RelatedStateUpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<RelatedStateUpdate<'bldr>> {
    let mut builder = RelatedStateUpdateBuilder::new(_fbb);
    if let Some(x) = args.state { builder.add_state(x); }
    if let Some(x) = args.related_to { builder.add_related_to(x); }
    builder.finish()
  }


  #[inline]
  pub fn related_to(&self) -> ContractInstanceId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContractInstanceId>>(RelatedStateUpdate::VT_RELATED_TO, None).unwrap()}
  }
  #[inline]
  pub fn state(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RelatedStateUpdate::VT_STATE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RelatedStateUpdate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContractInstanceId>>("related_to", Self::VT_RELATED_TO, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("state", Self::VT_STATE, true)?
     .finish();
    Ok(())
  }
}
pub struct RelatedStateUpdateArgs<'a> {
    pub related_to: Option<flatbuffers::WIPOffset<ContractInstanceId<'a>>>,
    pub state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RelatedStateUpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelatedStateUpdateArgs {
      related_to: None, // required field
      state: None, // required field
    }
  }
}

pub struct RelatedStateUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelatedStateUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_related_to(&mut self, related_to: flatbuffers::WIPOffset<ContractInstanceId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContractInstanceId>>(RelatedStateUpdate::VT_RELATED_TO, related_to);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelatedStateUpdate::VT_STATE, state);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelatedStateUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelatedStateUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelatedStateUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RelatedStateUpdate::VT_RELATED_TO,"related_to");
    self.fbb_.required(o, RelatedStateUpdate::VT_STATE,"state");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelatedStateUpdate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelatedStateUpdate");
      ds.field("related_to", &self.related_to());
      ds.field("state", &self.state());
      ds.finish()
  }
}
pub enum RelatedDeltaUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelatedDeltaUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelatedDeltaUpdate<'a> {
  type Inner = RelatedDeltaUpdate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelatedDeltaUpdate<'a> {
  pub const VT_RELATED_TO: flatbuffers::VOffsetT = 4;
  pub const VT_DELTA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelatedDeltaUpdate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RelatedDeltaUpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<RelatedDeltaUpdate<'bldr>> {
    let mut builder = RelatedDeltaUpdateBuilder::new(_fbb);
    if let Some(x) = args.delta { builder.add_delta(x); }
    if let Some(x) = args.related_to { builder.add_related_to(x); }
    builder.finish()
  }


  #[inline]
  pub fn related_to(&self) -> ContractInstanceId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContractInstanceId>>(RelatedDeltaUpdate::VT_RELATED_TO, None).unwrap()}
  }
  #[inline]
  pub fn delta(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RelatedDeltaUpdate::VT_DELTA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RelatedDeltaUpdate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContractInstanceId>>("related_to", Self::VT_RELATED_TO, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("delta", Self::VT_DELTA, true)?
     .finish();
    Ok(())
  }
}
pub struct RelatedDeltaUpdateArgs<'a> {
    pub related_to: Option<flatbuffers::WIPOffset<ContractInstanceId<'a>>>,
    pub delta: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RelatedDeltaUpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelatedDeltaUpdateArgs {
      related_to: None, // required field
      delta: None, // required field
    }
  }
}

pub struct RelatedDeltaUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelatedDeltaUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_related_to(&mut self, related_to: flatbuffers::WIPOffset<ContractInstanceId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContractInstanceId>>(RelatedDeltaUpdate::VT_RELATED_TO, related_to);
  }
  #[inline]
  pub fn add_delta(&mut self, delta: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelatedDeltaUpdate::VT_DELTA, delta);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelatedDeltaUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelatedDeltaUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelatedDeltaUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RelatedDeltaUpdate::VT_RELATED_TO,"related_to");
    self.fbb_.required(o, RelatedDeltaUpdate::VT_DELTA,"delta");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelatedDeltaUpdate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelatedDeltaUpdate");
      ds.field("related_to", &self.related_to());
      ds.field("delta", &self.delta());
      ds.finish()
  }
}
pub enum RelatedStateAndDeltaUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelatedStateAndDeltaUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelatedStateAndDeltaUpdate<'a> {
  type Inner = RelatedStateAndDeltaUpdate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelatedStateAndDeltaUpdate<'a> {
  pub const VT_RELATED_TO: flatbuffers::VOffsetT = 4;
  pub const VT_STATE: flatbuffers::VOffsetT = 6;
  pub const VT_DELTA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelatedStateAndDeltaUpdate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RelatedStateAndDeltaUpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<RelatedStateAndDeltaUpdate<'bldr>> {
    let mut builder = RelatedStateAndDeltaUpdateBuilder::new(_fbb);
    if let Some(x) = args.delta { builder.add_delta(x); }
    if let Some(x) = args.state { builder.add_state(x); }
    if let Some(x) = args.related_to { builder.add_related_to(x); }
    builder.finish()
  }


  #[inline]
  pub fn related_to(&self) -> ContractInstanceId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContractInstanceId>>(RelatedStateAndDeltaUpdate::VT_RELATED_TO, None).unwrap()}
  }
  #[inline]
  pub fn state(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RelatedStateAndDeltaUpdate::VT_STATE, None).unwrap()}
  }
  #[inline]
  pub fn delta(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RelatedStateAndDeltaUpdate::VT_DELTA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RelatedStateAndDeltaUpdate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContractInstanceId>>("related_to", Self::VT_RELATED_TO, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("state", Self::VT_STATE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("delta", Self::VT_DELTA, true)?
     .finish();
    Ok(())
  }
}
pub struct RelatedStateAndDeltaUpdateArgs<'a> {
    pub related_to: Option<flatbuffers::WIPOffset<ContractInstanceId<'a>>>,
    pub state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub delta: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RelatedStateAndDeltaUpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelatedStateAndDeltaUpdateArgs {
      related_to: None, // required field
      state: None, // required field
      delta: None, // required field
    }
  }
}

pub struct RelatedStateAndDeltaUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelatedStateAndDeltaUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_related_to(&mut self, related_to: flatbuffers::WIPOffset<ContractInstanceId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContractInstanceId>>(RelatedStateAndDeltaUpdate::VT_RELATED_TO, related_to);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelatedStateAndDeltaUpdate::VT_STATE, state);
  }
  #[inline]
  pub fn add_delta(&mut self, delta: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelatedStateAndDeltaUpdate::VT_DELTA, delta);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelatedStateAndDeltaUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelatedStateAndDeltaUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelatedStateAndDeltaUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RelatedStateAndDeltaUpdate::VT_RELATED_TO,"related_to");
    self.fbb_.required(o, RelatedStateAndDeltaUpdate::VT_STATE,"state");
    self.fbb_.required(o, RelatedStateAndDeltaUpdate::VT_DELTA,"delta");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelatedStateAndDeltaUpdate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelatedStateAndDeltaUpdate");
      ds.field("related_to", &self.related_to());
      ds.field("state", &self.state());
      ds.field("delta", &self.delta());
      ds.finish()
  }
}
pub enum UpdateDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UpdateData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdateData<'a> {
  type Inner = UpdateData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UpdateData<'a> {
  pub const VT_UPDATE_DATA_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_UPDATE_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UpdateData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UpdateDataArgs
  ) -> flatbuffers::WIPOffset<UpdateData<'bldr>> {
    let mut builder = UpdateDataBuilder::new(_fbb);
    if let Some(x) = args.update_data { builder.add_update_data(x); }
    builder.add_update_data_type(args.update_data_type);
    builder.finish()
  }


  #[inline]
  pub fn update_data_type(&self) -> UpdateDataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UpdateDataType>(UpdateData::VT_UPDATE_DATA_TYPE, Some(UpdateDataType::NONE)).unwrap()}
  }
  #[inline]
  pub fn update_data(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(UpdateData::VT_UPDATE_DATA, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn update_data_as_state_update(&self) -> Option<StateUpdate<'a>> {
    if self.update_data_type() == UpdateDataType::StateUpdate {
      let u = self.update_data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { StateUpdate::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn update_data_as_delta_update(&self) -> Option<DeltaUpdate<'a>> {
    if self.update_data_type() == UpdateDataType::DeltaUpdate {
      let u = self.update_data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { DeltaUpdate::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn update_data_as_state_and_delta_update(&self) -> Option<StateAndDeltaUpdate<'a>> {
    if self.update_data_type() == UpdateDataType::StateAndDeltaUpdate {
      let u = self.update_data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { StateAndDeltaUpdate::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn update_data_as_related_state_update(&self) -> Option<RelatedStateUpdate<'a>> {
    if self.update_data_type() == UpdateDataType::RelatedStateUpdate {
      let u = self.update_data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { RelatedStateUpdate::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn update_data_as_related_delta_update(&self) -> Option<RelatedDeltaUpdate<'a>> {
    if self.update_data_type() == UpdateDataType::RelatedDeltaUpdate {
      let u = self.update_data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { RelatedDeltaUpdate::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn update_data_as_related_state_and_delta_update(&self) -> Option<RelatedStateAndDeltaUpdate<'a>> {
    if self.update_data_type() == UpdateDataType::RelatedStateAndDeltaUpdate {
      let u = self.update_data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { RelatedStateAndDeltaUpdate::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for UpdateData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<UpdateDataType, _>("update_data_type", Self::VT_UPDATE_DATA_TYPE, "update_data", Self::VT_UPDATE_DATA, true, |key, v, pos| {
        match key {
          UpdateDataType::StateUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StateUpdate>>("UpdateDataType::StateUpdate", pos),
          UpdateDataType::DeltaUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DeltaUpdate>>("UpdateDataType::DeltaUpdate", pos),
          UpdateDataType::StateAndDeltaUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StateAndDeltaUpdate>>("UpdateDataType::StateAndDeltaUpdate", pos),
          UpdateDataType::RelatedStateUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RelatedStateUpdate>>("UpdateDataType::RelatedStateUpdate", pos),
          UpdateDataType::RelatedDeltaUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RelatedDeltaUpdate>>("UpdateDataType::RelatedDeltaUpdate", pos),
          UpdateDataType::RelatedStateAndDeltaUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RelatedStateAndDeltaUpdate>>("UpdateDataType::RelatedStateAndDeltaUpdate", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct UpdateDataArgs {
    pub update_data_type: UpdateDataType,
    pub update_data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for UpdateDataArgs {
  #[inline]
  fn default() -> Self {
    UpdateDataArgs {
      update_data_type: UpdateDataType::NONE,
      update_data: None, // required field
    }
  }
}

pub struct UpdateDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_update_data_type(&mut self, update_data_type: UpdateDataType) {
    self.fbb_.push_slot::<UpdateDataType>(UpdateData::VT_UPDATE_DATA_TYPE, update_data_type, UpdateDataType::NONE);
  }
  #[inline]
  pub fn add_update_data(&mut self, update_data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateData::VT_UPDATE_DATA, update_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdateData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, UpdateData::VT_UPDATE_DATA,"update_data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UpdateData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UpdateData");
      ds.field("update_data_type", &self.update_data_type());
      match self.update_data_type() {
        UpdateDataType::StateUpdate => {
          if let Some(x) = self.update_data_as_state_update() {
            ds.field("update_data", &x)
          } else {
            ds.field("update_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        UpdateDataType::DeltaUpdate => {
          if let Some(x) = self.update_data_as_delta_update() {
            ds.field("update_data", &x)
          } else {
            ds.field("update_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        UpdateDataType::StateAndDeltaUpdate => {
          if let Some(x) = self.update_data_as_state_and_delta_update() {
            ds.field("update_data", &x)
          } else {
            ds.field("update_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        UpdateDataType::RelatedStateUpdate => {
          if let Some(x) = self.update_data_as_related_state_update() {
            ds.field("update_data", &x)
          } else {
            ds.field("update_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        UpdateDataType::RelatedDeltaUpdate => {
          if let Some(x) = self.update_data_as_related_delta_update() {
            ds.field("update_data", &x)
          } else {
            ds.field("update_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        UpdateDataType::RelatedStateAndDeltaUpdate => {
          if let Some(x) = self.update_data_as_related_state_and_delta_update() {
            ds.field("update_data", &x)
          } else {
            ds.field("update_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("update_data", &x)
        },
      };
      ds.finish()
  }
}
}  // pub mod common

