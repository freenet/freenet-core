// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod topology {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PEER_CHANGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PEER_CHANGE_TYPE: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PEER_CHANGE_TYPE: [PeerChangeType; 4] = [
  PeerChangeType::NONE,
  PeerChangeType::AddedConnection,
  PeerChangeType::RemovedConnection,
  PeerChangeType::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PeerChangeType(pub u8);
#[allow(non_upper_case_globals)]
impl PeerChangeType {
  pub const NONE: Self = Self(0);
  pub const AddedConnection: Self = Self(1);
  pub const RemovedConnection: Self = Self(2);
  pub const Error: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::AddedConnection,
    Self::RemovedConnection,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::AddedConnection => Some("AddedConnection"),
      Self::RemovedConnection => Some("RemovedConnection"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PeerChangeType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PeerChangeType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PeerChangeType {
    type Output = PeerChangeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PeerChangeType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PeerChangeType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PeerChangeType {}
pub struct PeerChangeTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RESPONSE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RESPONSE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE: [Response; 3] = [
  Response::NONE,
  Response::Error,
  Response::Ok,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Response(pub u8);
#[allow(non_upper_case_globals)]
impl Response {
  pub const NONE: Self = Self(0);
  pub const Error: Self = Self(1);
  pub const Ok: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Error,
    Self::Ok,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Error => Some("Error"),
      Self::Ok => Some("Ok"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Response {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Response {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Response {
    type Output = Response;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Response {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Response {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Response {}
pub struct ResponseUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTRACT_CHANGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTRACT_CHANGE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTRACT_CHANGE_TYPE: [ContractChangeType; 11] = [
  ContractChangeType::NONE,
  ContractChangeType::PutRequest,
  ContractChangeType::PutSuccess,
  ContractChangeType::PutFailure,
  ContractChangeType::BroadcastEmitted,
  ContractChangeType::BroadcastReceived,
  ContractChangeType::UpdateRequest,
  ContractChangeType::UpdateSuccess,
  ContractChangeType::UpdateFailure,
  ContractChangeType::GetContract,
  ContractChangeType::SubscribedToContract,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ContractChangeType(pub u8);
#[allow(non_upper_case_globals)]
impl ContractChangeType {
  pub const NONE: Self = Self(0);
  pub const PutRequest: Self = Self(1);
  pub const PutSuccess: Self = Self(2);
  pub const PutFailure: Self = Self(3);
  pub const BroadcastEmitted: Self = Self(4);
  pub const BroadcastReceived: Self = Self(5);
  pub const UpdateRequest: Self = Self(6);
  pub const UpdateSuccess: Self = Self(7);
  pub const UpdateFailure: Self = Self(8);
  pub const GetContract: Self = Self(9);
  pub const SubscribedToContract: Self = Self(10);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PutRequest,
    Self::PutSuccess,
    Self::PutFailure,
    Self::BroadcastEmitted,
    Self::BroadcastReceived,
    Self::UpdateRequest,
    Self::UpdateSuccess,
    Self::UpdateFailure,
    Self::GetContract,
    Self::SubscribedToContract,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PutRequest => Some("PutRequest"),
      Self::PutSuccess => Some("PutSuccess"),
      Self::PutFailure => Some("PutFailure"),
      Self::BroadcastEmitted => Some("BroadcastEmitted"),
      Self::BroadcastReceived => Some("BroadcastReceived"),
      Self::UpdateRequest => Some("UpdateRequest"),
      Self::UpdateSuccess => Some("UpdateSuccess"),
      Self::UpdateFailure => Some("UpdateFailure"),
      Self::GetContract => Some("GetContract"),
      Self::SubscribedToContract => Some("SubscribedToContract"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ContractChangeType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ContractChangeType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ContractChangeType {
    type Output = ContractChangeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ContractChangeType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ContractChangeType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ContractChangeType {}
pub struct ContractChangeTypeUnionTableOffset {}

pub enum AddedConnectionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AddedConnection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddedConnection<'a> {
  type Inner = AddedConnection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AddedConnection<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_FROM: flatbuffers::VOffsetT = 6;
  pub const VT_FROM_LOCATION: flatbuffers::VOffsetT = 8;
  pub const VT_TO: flatbuffers::VOffsetT = 10;
  pub const VT_TO_LOCATION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AddedConnection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AddedConnectionArgs<'args>
  ) -> flatbuffers::WIPOffset<AddedConnection<'bldr>> {
    let mut builder = AddedConnectionBuilder::new(_fbb);
    builder.add_to_location(args.to_location);
    builder.add_from_location(args.from_location);
    if let Some(x) = args.to { builder.add_to(x); }
    if let Some(x) = args.from { builder.add_from(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AddedConnection::VT_TRANSACTION, None)}
  }
  #[inline]
  pub fn from(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(AddedConnection::VT_FROM, None).unwrap()}
  }
  #[inline]
  pub fn from_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AddedConnection::VT_FROM_LOCATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn to(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(AddedConnection::VT_TO, None).unwrap()}
  }
  #[inline]
  pub fn to_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AddedConnection::VT_TO_LOCATION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AddedConnection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("from", Self::VT_FROM, true)?
     .visit_field::<f64>("from_location", Self::VT_FROM_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("to", Self::VT_TO, true)?
     .visit_field::<f64>("to_location", Self::VT_TO_LOCATION, false)?
     .finish();
    Ok(())
  }
}
pub struct AddedConnectionArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub from: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub from_location: f64,
    pub to: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub to_location: f64,
}
impl<'a> Default for AddedConnectionArgs<'a> {
  #[inline]
  fn default() -> Self {
    AddedConnectionArgs {
      transaction: None,
      from: None, // required field
      from_location: 0.0,
      to: None, // required field
      to_location: 0.0,
    }
  }
}

pub struct AddedConnectionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddedConnectionBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AddedConnection::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_from(&mut self, from: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AddedConnection::VT_FROM, from);
  }
  #[inline]
  pub fn add_from_location(&mut self, from_location: f64) {
    self.fbb_.push_slot::<f64>(AddedConnection::VT_FROM_LOCATION, from_location, 0.0);
  }
  #[inline]
  pub fn add_to(&mut self, to: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AddedConnection::VT_TO, to);
  }
  #[inline]
  pub fn add_to_location(&mut self, to_location: f64) {
    self.fbb_.push_slot::<f64>(AddedConnection::VT_TO_LOCATION, to_location, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddedConnectionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddedConnectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AddedConnection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, AddedConnection::VT_FROM,"from");
    self.fbb_.required(o, AddedConnection::VT_TO,"to");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AddedConnection<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AddedConnection");
      ds.field("transaction", &self.transaction());
      ds.field("from", &self.from());
      ds.field("from_location", &self.from_location());
      ds.field("to", &self.to());
      ds.field("to_location", &self.to_location());
      ds.finish()
  }
}
pub enum RemovedConnectionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RemovedConnection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RemovedConnection<'a> {
  type Inner = RemovedConnection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RemovedConnection<'a> {
  pub const VT_AT: flatbuffers::VOffsetT = 4;
  pub const VT_FROM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RemovedConnection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RemovedConnectionArgs<'args>
  ) -> flatbuffers::WIPOffset<RemovedConnection<'bldr>> {
    let mut builder = RemovedConnectionBuilder::new(_fbb);
    if let Some(x) = args.from { builder.add_from(x); }
    if let Some(x) = args.at { builder.add_at(x); }
    builder.finish()
  }


  #[inline]
  pub fn at(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RemovedConnection::VT_AT, None).unwrap()}
  }
  #[inline]
  pub fn from(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RemovedConnection::VT_FROM, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RemovedConnection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("at", Self::VT_AT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("from", Self::VT_FROM, true)?
     .finish();
    Ok(())
  }
}
pub struct RemovedConnectionArgs<'a> {
    pub at: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub from: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RemovedConnectionArgs<'a> {
  #[inline]
  fn default() -> Self {
    RemovedConnectionArgs {
      at: None, // required field
      from: None, // required field
    }
  }
}

pub struct RemovedConnectionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RemovedConnectionBuilder<'a, 'b> {
  #[inline]
  pub fn add_at(&mut self, at: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RemovedConnection::VT_AT, at);
  }
  #[inline]
  pub fn add_from(&mut self, from: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RemovedConnection::VT_FROM, from);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RemovedConnectionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RemovedConnectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RemovedConnection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RemovedConnection::VT_AT,"at");
    self.fbb_.required(o, RemovedConnection::VT_FROM,"from");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RemovedConnection<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RemovedConnection");
      ds.field("at", &self.at());
      ds.field("from", &self.from());
      ds.finish()
  }
}
pub enum ErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Error<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Error<'a> {
  type Inner = Error<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Error<'a> {
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Error { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ErrorArgs<'args>
  ) -> flatbuffers::WIPOffset<Error<'bldr>> {
    let mut builder = ErrorBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.finish()
  }


  #[inline]
  pub fn message(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_MESSAGE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Error<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, true)?
     .finish();
    Ok(())
  }
}
pub struct ErrorArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorArgs {
      message: None, // required field
    }
  }
}

pub struct ErrorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ErrorBuilder<'a, 'b> {
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ErrorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Error::VT_MESSAGE,"message");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Error<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Error");
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum PeerChangeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PeerChange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PeerChange<'a> {
  type Inner = PeerChange<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PeerChange<'a> {
  pub const VT_CURRENT_STATE: flatbuffers::VOffsetT = 4;
  pub const VT_CHANGE_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_CHANGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PeerChange { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PeerChangeArgs<'args>
  ) -> flatbuffers::WIPOffset<PeerChange<'bldr>> {
    let mut builder = PeerChangeBuilder::new(_fbb);
    if let Some(x) = args.change { builder.add_change(x); }
    if let Some(x) = args.current_state { builder.add_current_state(x); }
    builder.add_change_type(args.change_type);
    builder.finish()
  }


  #[inline]
  pub fn current_state(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddedConnection<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddedConnection>>>>(PeerChange::VT_CURRENT_STATE, None)}
  }
  #[inline]
  pub fn change_type(&self) -> PeerChangeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PeerChangeType>(PeerChange::VT_CHANGE_TYPE, Some(PeerChangeType::NONE)).unwrap()}
  }
  #[inline]
  pub fn change(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(PeerChange::VT_CHANGE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_added_connection(&self) -> Option<AddedConnection<'a>> {
    if self.change_type() == PeerChangeType::AddedConnection {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AddedConnection::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_removed_connection(&self) -> Option<RemovedConnection<'a>> {
    if self.change_type() == PeerChangeType::RemovedConnection {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RemovedConnection::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_error(&self) -> Option<Error<'a>> {
    if self.change_type() == PeerChangeType::Error {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Error::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for PeerChange<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AddedConnection>>>>("current_state", Self::VT_CURRENT_STATE, false)?
     .visit_union::<PeerChangeType, _>("change_type", Self::VT_CHANGE_TYPE, "change", Self::VT_CHANGE, false, |key, v, pos| {
        match key {
          PeerChangeType::AddedConnection => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddedConnection>>("PeerChangeType::AddedConnection", pos),
          PeerChangeType::RemovedConnection => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RemovedConnection>>("PeerChangeType::RemovedConnection", pos),
          PeerChangeType::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>("PeerChangeType::Error", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct PeerChangeArgs<'a> {
    pub current_state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddedConnection<'a>>>>>,
    pub change_type: PeerChangeType,
    pub change: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PeerChangeArgs<'a> {
  #[inline]
  fn default() -> Self {
    PeerChangeArgs {
      current_state: None,
      change_type: PeerChangeType::NONE,
      change: None,
    }
  }
}

pub struct PeerChangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PeerChangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_current_state(&mut self, current_state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AddedConnection<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PeerChange::VT_CURRENT_STATE, current_state);
  }
  #[inline]
  pub fn add_change_type(&mut self, change_type: PeerChangeType) {
    self.fbb_.push_slot::<PeerChangeType>(PeerChange::VT_CHANGE_TYPE, change_type, PeerChangeType::NONE);
  }
  #[inline]
  pub fn add_change(&mut self, change: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PeerChange::VT_CHANGE, change);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PeerChangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PeerChangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PeerChange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PeerChange<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PeerChange");
      ds.field("current_state", &self.current_state());
      ds.field("change_type", &self.change_type());
      match self.change_type() {
        PeerChangeType::AddedConnection => {
          if let Some(x) = self.change_as_added_connection() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PeerChangeType::RemovedConnection => {
          if let Some(x) = self.change_as_removed_connection() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PeerChangeType::Error => {
          if let Some(x) = self.change_as_error() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("change", &x)
        },
      };
      ds.finish()
  }
}
pub enum OkOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Ok<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ok<'a> {
  type Inner = Ok<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Ok<'a> {
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Ok { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OkArgs<'args>
  ) -> flatbuffers::WIPOffset<Ok<'bldr>> {
    let mut builder = OkBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.finish()
  }


  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ok::VT_MESSAGE, None)}
  }
}

impl flatbuffers::Verifiable for Ok<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct OkArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OkArgs<'a> {
  #[inline]
  fn default() -> Self {
    OkArgs {
      message: None,
    }
  }
}

pub struct OkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OkBuilder<'a, 'b> {
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ok::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ok<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Ok<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Ok");
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum ControllerResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ControllerResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ControllerResponse<'a> {
  type Inner = ControllerResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ControllerResponse<'a> {
  pub const VT_RESPONSE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_RESPONSE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ControllerResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ControllerResponseArgs
  ) -> flatbuffers::WIPOffset<ControllerResponse<'bldr>> {
    let mut builder = ControllerResponseBuilder::new(_fbb);
    if let Some(x) = args.response { builder.add_response(x); }
    builder.add_response_type(args.response_type);
    builder.finish()
  }


  #[inline]
  pub fn response_type(&self) -> Response {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Response>(ControllerResponse::VT_RESPONSE_TYPE, Some(Response::NONE)).unwrap()}
  }
  #[inline]
  pub fn response(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ControllerResponse::VT_RESPONSE, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_error(&self) -> Option<Error<'a>> {
    if self.response_type() == Response::Error {
      let u = self.response();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Error::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_ok(&self) -> Option<Ok<'a>> {
    if self.response_type() == Response::Ok {
      let u = self.response();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Ok::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ControllerResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Response, _>("response_type", Self::VT_RESPONSE_TYPE, "response", Self::VT_RESPONSE, true, |key, v, pos| {
        match key {
          Response::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>("Response::Error", pos),
          Response::Ok => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Ok>>("Response::Ok", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ControllerResponseArgs {
    pub response_type: Response,
    pub response: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ControllerResponseArgs {
  #[inline]
  fn default() -> Self {
    ControllerResponseArgs {
      response_type: Response::NONE,
      response: None, // required field
    }
  }
}

pub struct ControllerResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ControllerResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_response_type(&mut self, response_type: Response) {
    self.fbb_.push_slot::<Response>(ControllerResponse::VT_RESPONSE_TYPE, response_type, Response::NONE);
  }
  #[inline]
  pub fn add_response(&mut self, response: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ControllerResponse::VT_RESPONSE, response);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ControllerResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ControllerResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ControllerResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ControllerResponse::VT_RESPONSE,"response");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ControllerResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ControllerResponse");
      ds.field("response_type", &self.response_type());
      match self.response_type() {
        Response::Error => {
          if let Some(x) = self.response_as_error() {
            ds.field("response", &x)
          } else {
            ds.field("response", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Response::Ok => {
          if let Some(x) = self.response_as_ok() {
            ds.field("response", &x)
          } else {
            ds.field("response", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("response", &x)
        },
      };
      ds.finish()
  }
}
pub enum PutRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PutRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PutRequest<'a> {
  type Inner = PutRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PutRequest<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 8;
  pub const VT_TARGET: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
  pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PutRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PutRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<PutRequest<'bldr>> {
    let mut builder = PutRequestBuilder::new(_fbb);
    builder.add_contract_location(args.contract_location);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.target { builder.add_target(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutRequest::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutRequest::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutRequest::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutRequest::VT_TARGET, None).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PutRequest::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn contract_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PutRequest::VT_CONTRACT_LOCATION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PutRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
     .finish();
    Ok(())
  }
}
pub struct PutRequestArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
    pub contract_location: f64,
}
impl<'a> Default for PutRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    PutRequestArgs {
      transaction: None, // required field
      key: None, // required field
      requester: None, // required field
      target: None, // required field
      timestamp: 0,
      contract_location: 0.0,
    }
  }
}

pub struct PutRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PutRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutRequest::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutRequest::VT_KEY, key);
  }
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutRequest::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutRequest::VT_TARGET, target);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(PutRequest::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_contract_location(&mut self, contract_location: f64) {
    self.fbb_.push_slot::<f64>(PutRequest::VT_CONTRACT_LOCATION, contract_location, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PutRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PutRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PutRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PutRequest::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, PutRequest::VT_KEY,"key");
    self.fbb_.required(o, PutRequest::VT_REQUESTER,"requester");
    self.fbb_.required(o, PutRequest::VT_TARGET,"target");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PutRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PutRequest");
      ds.field("transaction", &self.transaction());
      ds.field("key", &self.key());
      ds.field("requester", &self.requester());
      ds.field("target", &self.target());
      ds.field("timestamp", &self.timestamp());
      ds.field("contract_location", &self.contract_location());
      ds.finish()
  }
}
pub enum UpdateRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UpdateRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdateRequest<'a> {
  type Inner = UpdateRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UpdateRequest<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 8;
  pub const VT_TARGET: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UpdateRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UpdateRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<UpdateRequest<'bldr>> {
    let mut builder = UpdateRequestBuilder::new(_fbb);
    if let Some(x) = args.target { builder.add_target(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateRequest::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateRequest::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateRequest::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateRequest::VT_TARGET, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for UpdateRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
     .finish();
    Ok(())
  }
}
pub struct UpdateRequestArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UpdateRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    UpdateRequestArgs {
      transaction: None, // required field
      key: None, // required field
      requester: None, // required field
      target: None, // required field
    }
  }
}

pub struct UpdateRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateRequest::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateRequest::VT_KEY, key);
  }
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateRequest::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateRequest::VT_TARGET, target);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdateRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, UpdateRequest::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, UpdateRequest::VT_KEY,"key");
    self.fbb_.required(o, UpdateRequest::VT_REQUESTER,"requester");
    self.fbb_.required(o, UpdateRequest::VT_TARGET,"target");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UpdateRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UpdateRequest");
      ds.field("transaction", &self.transaction());
      ds.field("key", &self.key());
      ds.field("requester", &self.requester());
      ds.field("target", &self.target());
      ds.finish()
  }
}
pub enum PutSuccessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PutSuccess<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PutSuccess<'a> {
  type Inner = PutSuccess<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PutSuccess<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 6;
  pub const VT_TARGET: flatbuffers::VOffsetT = 8;
  pub const VT_KEY: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
  pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PutSuccess { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PutSuccessArgs<'args>
  ) -> flatbuffers::WIPOffset<PutSuccess<'bldr>> {
    let mut builder = PutSuccessBuilder::new(_fbb);
    builder.add_contract_location(args.contract_location);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.target { builder.add_target(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutSuccess::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutSuccess::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutSuccess::VT_TARGET, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutSuccess::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PutSuccess::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn contract_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PutSuccess::VT_CONTRACT_LOCATION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PutSuccess<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
     .finish();
    Ok(())
  }
}
pub struct PutSuccessArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
    pub contract_location: f64,
}
impl<'a> Default for PutSuccessArgs<'a> {
  #[inline]
  fn default() -> Self {
    PutSuccessArgs {
      transaction: None, // required field
      requester: None, // required field
      target: None, // required field
      key: None, // required field
      timestamp: 0,
      contract_location: 0.0,
    }
  }
}

pub struct PutSuccessBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PutSuccessBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutSuccess::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutSuccess::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutSuccess::VT_TARGET, target);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutSuccess::VT_KEY, key);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(PutSuccess::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_contract_location(&mut self, contract_location: f64) {
    self.fbb_.push_slot::<f64>(PutSuccess::VT_CONTRACT_LOCATION, contract_location, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PutSuccessBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PutSuccessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PutSuccess<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PutSuccess::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, PutSuccess::VT_REQUESTER,"requester");
    self.fbb_.required(o, PutSuccess::VT_TARGET,"target");
    self.fbb_.required(o, PutSuccess::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PutSuccess<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PutSuccess");
      ds.field("transaction", &self.transaction());
      ds.field("requester", &self.requester());
      ds.field("target", &self.target());
      ds.field("key", &self.key());
      ds.field("timestamp", &self.timestamp());
      ds.field("contract_location", &self.contract_location());
      ds.finish()
  }
}
pub enum PutFailureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PutFailure<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PutFailure<'a> {
  type Inner = PutFailure<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PutFailure<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 6;
  pub const VT_TARGET: flatbuffers::VOffsetT = 8;
  pub const VT_KEY: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PutFailure { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PutFailureArgs<'args>
  ) -> flatbuffers::WIPOffset<PutFailure<'bldr>> {
    let mut builder = PutFailureBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.target { builder.add_target(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutFailure::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutFailure::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutFailure::VT_TARGET, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PutFailure::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PutFailure::VT_TIMESTAMP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PutFailure<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct PutFailureArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
}
impl<'a> Default for PutFailureArgs<'a> {
  #[inline]
  fn default() -> Self {
    PutFailureArgs {
      transaction: None, // required field
      requester: None, // required field
      target: None, // required field
      key: None, // required field
      timestamp: 0,
    }
  }
}

pub struct PutFailureBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PutFailureBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutFailure::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutFailure::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutFailure::VT_TARGET, target);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PutFailure::VT_KEY, key);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(PutFailure::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PutFailureBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PutFailureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PutFailure<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PutFailure::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, PutFailure::VT_REQUESTER,"requester");
    self.fbb_.required(o, PutFailure::VT_TARGET,"target");
    self.fbb_.required(o, PutFailure::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PutFailure<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PutFailure");
      ds.field("transaction", &self.transaction());
      ds.field("requester", &self.requester());
      ds.field("target", &self.target());
      ds.field("key", &self.key());
      ds.field("timestamp", &self.timestamp());
      ds.finish()
  }
}
pub enum UpdateSuccessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UpdateSuccess<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdateSuccess<'a> {
  type Inner = UpdateSuccess<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UpdateSuccess<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 6;
  pub const VT_TARGET: flatbuffers::VOffsetT = 8;
  pub const VT_KEY: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UpdateSuccess { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UpdateSuccessArgs<'args>
  ) -> flatbuffers::WIPOffset<UpdateSuccess<'bldr>> {
    let mut builder = UpdateSuccessBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.target { builder.add_target(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateSuccess::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateSuccess::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateSuccess::VT_TARGET, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateSuccess::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UpdateSuccess::VT_TIMESTAMP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UpdateSuccess<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct UpdateSuccessArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
}
impl<'a> Default for UpdateSuccessArgs<'a> {
  #[inline]
  fn default() -> Self {
    UpdateSuccessArgs {
      transaction: None, // required field
      requester: None, // required field
      target: None, // required field
      key: None, // required field
      timestamp: 0,
    }
  }
}

pub struct UpdateSuccessBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateSuccessBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateSuccess::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateSuccess::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateSuccess::VT_TARGET, target);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateSuccess::VT_KEY, key);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(UpdateSuccess::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateSuccessBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateSuccessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdateSuccess<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, UpdateSuccess::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, UpdateSuccess::VT_REQUESTER,"requester");
    self.fbb_.required(o, UpdateSuccess::VT_TARGET,"target");
    self.fbb_.required(o, UpdateSuccess::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UpdateSuccess<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UpdateSuccess");
      ds.field("transaction", &self.transaction());
      ds.field("requester", &self.requester());
      ds.field("target", &self.target());
      ds.field("key", &self.key());
      ds.field("timestamp", &self.timestamp());
      ds.finish()
  }
}
pub enum UpdateFailureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UpdateFailure<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdateFailure<'a> {
  type Inner = UpdateFailure<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UpdateFailure<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 6;
  pub const VT_TARGET: flatbuffers::VOffsetT = 8;
  pub const VT_KEY: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UpdateFailure { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UpdateFailureArgs<'args>
  ) -> flatbuffers::WIPOffset<UpdateFailure<'bldr>> {
    let mut builder = UpdateFailureBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.target { builder.add_target(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateFailure::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateFailure::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateFailure::VT_TARGET, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateFailure::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UpdateFailure::VT_TIMESTAMP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UpdateFailure<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct UpdateFailureArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
}
impl<'a> Default for UpdateFailureArgs<'a> {
  #[inline]
  fn default() -> Self {
    UpdateFailureArgs {
      transaction: None, // required field
      requester: None, // required field
      target: None, // required field
      key: None, // required field
      timestamp: 0,
    }
  }
}

pub struct UpdateFailureBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateFailureBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateFailure::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateFailure::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateFailure::VT_TARGET, target);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateFailure::VT_KEY, key);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(UpdateFailure::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateFailureBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateFailureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdateFailure<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, UpdateFailure::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, UpdateFailure::VT_REQUESTER,"requester");
    self.fbb_.required(o, UpdateFailure::VT_TARGET,"target");
    self.fbb_.required(o, UpdateFailure::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UpdateFailure<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UpdateFailure");
      ds.field("transaction", &self.transaction());
      ds.field("requester", &self.requester());
      ds.field("target", &self.target());
      ds.field("key", &self.key());
      ds.field("timestamp", &self.timestamp());
      ds.finish()
  }
}
pub enum BroadcastEmittedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BroadcastEmitted<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BroadcastEmitted<'a> {
  type Inner = BroadcastEmitted<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BroadcastEmitted<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_UPSTREAM: flatbuffers::VOffsetT = 6;
  pub const VT_BROADCAST_TO: flatbuffers::VOffsetT = 8;
  pub const VT_BROADCASTED_TO: flatbuffers::VOffsetT = 10;
  pub const VT_KEY: flatbuffers::VOffsetT = 12;
  pub const VT_SENDER: flatbuffers::VOffsetT = 14;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 16;
  pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BroadcastEmitted { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BroadcastEmittedArgs<'args>
  ) -> flatbuffers::WIPOffset<BroadcastEmitted<'bldr>> {
    let mut builder = BroadcastEmittedBuilder::new(_fbb);
    builder.add_contract_location(args.contract_location);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.sender { builder.add_sender(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_broadcasted_to(args.broadcasted_to);
    if let Some(x) = args.broadcast_to { builder.add_broadcast_to(x); }
    if let Some(x) = args.upstream { builder.add_upstream(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastEmitted::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn upstream(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastEmitted::VT_UPSTREAM, None).unwrap()}
  }
  #[inline]
  pub fn broadcast_to(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(BroadcastEmitted::VT_BROADCAST_TO, None)}
  }
  #[inline]
  pub fn broadcasted_to(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BroadcastEmitted::VT_BROADCASTED_TO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastEmitted::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn sender(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastEmitted::VT_SENDER, None).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BroadcastEmitted::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn contract_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BroadcastEmitted::VT_CONTRACT_LOCATION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BroadcastEmitted<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("upstream", Self::VT_UPSTREAM, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("broadcast_to", Self::VT_BROADCAST_TO, false)?
     .visit_field::<u32>("broadcasted_to", Self::VT_BROADCASTED_TO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender", Self::VT_SENDER, true)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
     .finish();
    Ok(())
  }
}
pub struct BroadcastEmittedArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub upstream: Option<flatbuffers::WIPOffset<&'a str>>,
    pub broadcast_to: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub broadcasted_to: u32,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
    pub contract_location: f64,
}
impl<'a> Default for BroadcastEmittedArgs<'a> {
  #[inline]
  fn default() -> Self {
    BroadcastEmittedArgs {
      transaction: None, // required field
      upstream: None, // required field
      broadcast_to: None,
      broadcasted_to: 0,
      key: None, // required field
      sender: None, // required field
      timestamp: 0,
      contract_location: 0.0,
    }
  }
}

pub struct BroadcastEmittedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BroadcastEmittedBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastEmitted::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_upstream(&mut self, upstream: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastEmitted::VT_UPSTREAM, upstream);
  }
  #[inline]
  pub fn add_broadcast_to(&mut self, broadcast_to: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastEmitted::VT_BROADCAST_TO, broadcast_to);
  }
  #[inline]
  pub fn add_broadcasted_to(&mut self, broadcasted_to: u32) {
    self.fbb_.push_slot::<u32>(BroadcastEmitted::VT_BROADCASTED_TO, broadcasted_to, 0);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastEmitted::VT_KEY, key);
  }
  #[inline]
  pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastEmitted::VT_SENDER, sender);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(BroadcastEmitted::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_contract_location(&mut self, contract_location: f64) {
    self.fbb_.push_slot::<f64>(BroadcastEmitted::VT_CONTRACT_LOCATION, contract_location, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BroadcastEmittedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BroadcastEmittedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BroadcastEmitted<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, BroadcastEmitted::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, BroadcastEmitted::VT_UPSTREAM,"upstream");
    self.fbb_.required(o, BroadcastEmitted::VT_KEY,"key");
    self.fbb_.required(o, BroadcastEmitted::VT_SENDER,"sender");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BroadcastEmitted<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BroadcastEmitted");
      ds.field("transaction", &self.transaction());
      ds.field("upstream", &self.upstream());
      ds.field("broadcast_to", &self.broadcast_to());
      ds.field("broadcasted_to", &self.broadcasted_to());
      ds.field("key", &self.key());
      ds.field("sender", &self.sender());
      ds.field("timestamp", &self.timestamp());
      ds.field("contract_location", &self.contract_location());
      ds.finish()
  }
}
pub enum BroadcastReceivedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BroadcastReceived<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BroadcastReceived<'a> {
  type Inner = BroadcastReceived<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BroadcastReceived<'a> {
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET: flatbuffers::VOffsetT = 6;
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 8;
  pub const VT_KEY: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
  pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BroadcastReceived { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BroadcastReceivedArgs<'args>
  ) -> flatbuffers::WIPOffset<BroadcastReceived<'bldr>> {
    let mut builder = BroadcastReceivedBuilder::new(_fbb);
    builder.add_contract_location(args.contract_location);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    if let Some(x) = args.target { builder.add_target(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastReceived::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastReceived::VT_TARGET, None).unwrap()}
  }
  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastReceived::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BroadcastReceived::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BroadcastReceived::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn contract_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BroadcastReceived::VT_CONTRACT_LOCATION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BroadcastReceived<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
     .finish();
    Ok(())
  }
}
pub struct BroadcastReceivedArgs<'a> {
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
    pub contract_location: f64,
}
impl<'a> Default for BroadcastReceivedArgs<'a> {
  #[inline]
  fn default() -> Self {
    BroadcastReceivedArgs {
      transaction: None, // required field
      target: None, // required field
      requester: None, // required field
      key: None, // required field
      timestamp: 0,
      contract_location: 0.0,
    }
  }
}

pub struct BroadcastReceivedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BroadcastReceivedBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastReceived::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastReceived::VT_TARGET, target);
  }
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastReceived::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BroadcastReceived::VT_KEY, key);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(BroadcastReceived::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_contract_location(&mut self, contract_location: f64) {
    self.fbb_.push_slot::<f64>(BroadcastReceived::VT_CONTRACT_LOCATION, contract_location, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BroadcastReceivedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BroadcastReceivedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BroadcastReceived<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, BroadcastReceived::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, BroadcastReceived::VT_TARGET,"target");
    self.fbb_.required(o, BroadcastReceived::VT_REQUESTER,"requester");
    self.fbb_.required(o, BroadcastReceived::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BroadcastReceived<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BroadcastReceived");
      ds.field("transaction", &self.transaction());
      ds.field("target", &self.target());
      ds.field("requester", &self.requester());
      ds.field("key", &self.key());
      ds.field("timestamp", &self.timestamp());
      ds.field("contract_location", &self.contract_location());
      ds.finish()
  }
}
pub enum GetContractOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetContract<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetContract<'a> {
  type Inner = GetContract<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetContract<'a> {
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET: flatbuffers::VOffsetT = 6;
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 8;
  pub const VT_KEY: flatbuffers::VOffsetT = 10;
  pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 12;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetContract { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetContractArgs<'args>
  ) -> flatbuffers::WIPOffset<GetContract<'bldr>> {
    let mut builder = GetContractBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    builder.add_contract_location(args.contract_location);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    if let Some(x) = args.target { builder.add_target(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    builder.finish()
  }


  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetContract::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetContract::VT_TARGET, None).unwrap()}
  }
  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetContract::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetContract::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn contract_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GetContract::VT_CONTRACT_LOCATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GetContract::VT_TIMESTAMP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetContract<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct GetContractArgs<'a> {
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contract_location: f64,
    pub timestamp: u64,
}
impl<'a> Default for GetContractArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetContractArgs {
      requester: None, // required field
      target: None, // required field
      transaction: None, // required field
      key: None, // required field
      contract_location: 0.0,
      timestamp: 0,
    }
  }
}

pub struct GetContractBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetContractBuilder<'a, 'b> {
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetContract::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetContract::VT_TARGET, target);
  }
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetContract::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetContract::VT_KEY, key);
  }
  #[inline]
  pub fn add_contract_location(&mut self, contract_location: f64) {
    self.fbb_.push_slot::<f64>(GetContract::VT_CONTRACT_LOCATION, contract_location, 0.0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(GetContract::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetContractBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetContractBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetContract<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, GetContract::VT_REQUESTER,"requester");
    self.fbb_.required(o, GetContract::VT_TARGET,"target");
    self.fbb_.required(o, GetContract::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, GetContract::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetContract<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetContract");
      ds.field("requester", &self.requester());
      ds.field("target", &self.target());
      ds.field("transaction", &self.transaction());
      ds.field("key", &self.key());
      ds.field("contract_location", &self.contract_location());
      ds.field("timestamp", &self.timestamp());
      ds.finish()
  }
}
pub enum SubscribedToContractOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubscribedToContract<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubscribedToContract<'a> {
  type Inner = SubscribedToContract<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SubscribedToContract<'a> {
  pub const VT_REQUESTER: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSACTION: flatbuffers::VOffsetT = 6;
  pub const VT_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_CONTRACT_LOCATION: flatbuffers::VOffsetT = 10;
  pub const VT_AT_PEER: flatbuffers::VOffsetT = 12;
  pub const VT_AT_PEER_LOCATION: flatbuffers::VOffsetT = 14;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubscribedToContract { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubscribedToContractArgs<'args>
  ) -> flatbuffers::WIPOffset<SubscribedToContract<'bldr>> {
    let mut builder = SubscribedToContractBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    builder.add_at_peer_location(args.at_peer_location);
    builder.add_contract_location(args.contract_location);
    if let Some(x) = args.at_peer { builder.add_at_peer(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.transaction { builder.add_transaction(x); }
    if let Some(x) = args.requester { builder.add_requester(x); }
    builder.finish()
  }


  #[inline]
  pub fn requester(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubscribedToContract::VT_REQUESTER, None).unwrap()}
  }
  #[inline]
  pub fn transaction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubscribedToContract::VT_TRANSACTION, None).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubscribedToContract::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn contract_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SubscribedToContract::VT_CONTRACT_LOCATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn at_peer(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubscribedToContract::VT_AT_PEER, None).unwrap()}
  }
  #[inline]
  pub fn at_peer_location(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SubscribedToContract::VT_AT_PEER_LOCATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SubscribedToContract::VT_TIMESTAMP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SubscribedToContract<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("requester", Self::VT_REQUESTER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction", Self::VT_TRANSACTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<f64>("contract_location", Self::VT_CONTRACT_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("at_peer", Self::VT_AT_PEER, true)?
     .visit_field::<f64>("at_peer_location", Self::VT_AT_PEER_LOCATION, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscribedToContractArgs<'a> {
    pub requester: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transaction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contract_location: f64,
    pub at_peer: Option<flatbuffers::WIPOffset<&'a str>>,
    pub at_peer_location: f64,
    pub timestamp: u64,
}
impl<'a> Default for SubscribedToContractArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscribedToContractArgs {
      requester: None, // required field
      transaction: None, // required field
      key: None, // required field
      contract_location: 0.0,
      at_peer: None, // required field
      at_peer_location: 0.0,
      timestamp: 0,
    }
  }
}

pub struct SubscribedToContractBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubscribedToContractBuilder<'a, 'b> {
  #[inline]
  pub fn add_requester(&mut self, requester: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscribedToContract::VT_REQUESTER, requester);
  }
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscribedToContract::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscribedToContract::VT_KEY, key);
  }
  #[inline]
  pub fn add_contract_location(&mut self, contract_location: f64) {
    self.fbb_.push_slot::<f64>(SubscribedToContract::VT_CONTRACT_LOCATION, contract_location, 0.0);
  }
  #[inline]
  pub fn add_at_peer(&mut self, at_peer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscribedToContract::VT_AT_PEER, at_peer);
  }
  #[inline]
  pub fn add_at_peer_location(&mut self, at_peer_location: f64) {
    self.fbb_.push_slot::<f64>(SubscribedToContract::VT_AT_PEER_LOCATION, at_peer_location, 0.0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(SubscribedToContract::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubscribedToContractBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubscribedToContractBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubscribedToContract<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SubscribedToContract::VT_REQUESTER,"requester");
    self.fbb_.required(o, SubscribedToContract::VT_TRANSACTION,"transaction");
    self.fbb_.required(o, SubscribedToContract::VT_KEY,"key");
    self.fbb_.required(o, SubscribedToContract::VT_AT_PEER,"at_peer");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubscribedToContract<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubscribedToContract");
      ds.field("requester", &self.requester());
      ds.field("transaction", &self.transaction());
      ds.field("key", &self.key());
      ds.field("contract_location", &self.contract_location());
      ds.field("at_peer", &self.at_peer());
      ds.field("at_peer_location", &self.at_peer_location());
      ds.field("timestamp", &self.timestamp());
      ds.finish()
  }
}
pub enum ContractChangeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContractChange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContractChange<'a> {
  type Inner = ContractChange<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContractChange<'a> {
  pub const VT_CONTRACT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CHANGE_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_CHANGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContractChange { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContractChangeArgs<'args>
  ) -> flatbuffers::WIPOffset<ContractChange<'bldr>> {
    let mut builder = ContractChangeBuilder::new(_fbb);
    if let Some(x) = args.change { builder.add_change(x); }
    if let Some(x) = args.contract_id { builder.add_contract_id(x); }
    builder.add_change_type(args.change_type);
    builder.finish()
  }


  #[inline]
  pub fn contract_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContractChange::VT_CONTRACT_ID, None).unwrap()}
  }
  #[inline]
  pub fn change_type(&self) -> ContractChangeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ContractChangeType>(ContractChange::VT_CHANGE_TYPE, Some(ContractChangeType::NONE)).unwrap()}
  }
  #[inline]
  pub fn change(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ContractChange::VT_CHANGE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_put_request(&self) -> Option<PutRequest<'a>> {
    if self.change_type() == ContractChangeType::PutRequest {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PutRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_put_success(&self) -> Option<PutSuccess<'a>> {
    if self.change_type() == ContractChangeType::PutSuccess {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PutSuccess::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_put_failure(&self) -> Option<PutFailure<'a>> {
    if self.change_type() == ContractChangeType::PutFailure {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PutFailure::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_broadcast_emitted(&self) -> Option<BroadcastEmitted<'a>> {
    if self.change_type() == ContractChangeType::BroadcastEmitted {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BroadcastEmitted::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_broadcast_received(&self) -> Option<BroadcastReceived<'a>> {
    if self.change_type() == ContractChangeType::BroadcastReceived {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BroadcastReceived::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_update_request(&self) -> Option<UpdateRequest<'a>> {
    if self.change_type() == ContractChangeType::UpdateRequest {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UpdateRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_update_success(&self) -> Option<UpdateSuccess<'a>> {
    if self.change_type() == ContractChangeType::UpdateSuccess {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UpdateSuccess::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_update_failure(&self) -> Option<UpdateFailure<'a>> {
    if self.change_type() == ContractChangeType::UpdateFailure {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UpdateFailure::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_get_contract(&self) -> Option<GetContract<'a>> {
    if self.change_type() == ContractChangeType::GetContract {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetContract::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn change_as_subscribed_to_contract(&self) -> Option<SubscribedToContract<'a>> {
    if self.change_type() == ContractChangeType::SubscribedToContract {
      self.change().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SubscribedToContract::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ContractChange<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("contract_id", Self::VT_CONTRACT_ID, true)?
     .visit_union::<ContractChangeType, _>("change_type", Self::VT_CHANGE_TYPE, "change", Self::VT_CHANGE, false, |key, v, pos| {
        match key {
          ContractChangeType::PutRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PutRequest>>("ContractChangeType::PutRequest", pos),
          ContractChangeType::PutSuccess => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PutSuccess>>("ContractChangeType::PutSuccess", pos),
          ContractChangeType::PutFailure => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PutFailure>>("ContractChangeType::PutFailure", pos),
          ContractChangeType::BroadcastEmitted => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BroadcastEmitted>>("ContractChangeType::BroadcastEmitted", pos),
          ContractChangeType::BroadcastReceived => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BroadcastReceived>>("ContractChangeType::BroadcastReceived", pos),
          ContractChangeType::UpdateRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpdateRequest>>("ContractChangeType::UpdateRequest", pos),
          ContractChangeType::UpdateSuccess => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpdateSuccess>>("ContractChangeType::UpdateSuccess", pos),
          ContractChangeType::UpdateFailure => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpdateFailure>>("ContractChangeType::UpdateFailure", pos),
          ContractChangeType::GetContract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetContract>>("ContractChangeType::GetContract", pos),
          ContractChangeType::SubscribedToContract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SubscribedToContract>>("ContractChangeType::SubscribedToContract", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ContractChangeArgs<'a> {
    pub contract_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub change_type: ContractChangeType,
    pub change: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ContractChangeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContractChangeArgs {
      contract_id: None, // required field
      change_type: ContractChangeType::NONE,
      change: None,
    }
  }
}

pub struct ContractChangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContractChangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_contract_id(&mut self, contract_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContractChange::VT_CONTRACT_ID, contract_id);
  }
  #[inline]
  pub fn add_change_type(&mut self, change_type: ContractChangeType) {
    self.fbb_.push_slot::<ContractChangeType>(ContractChange::VT_CHANGE_TYPE, change_type, ContractChangeType::NONE);
  }
  #[inline]
  pub fn add_change(&mut self, change: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContractChange::VT_CHANGE, change);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContractChangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContractChangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContractChange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContractChange::VT_CONTRACT_ID,"contract_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContractChange<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContractChange");
      ds.field("contract_id", &self.contract_id());
      ds.field("change_type", &self.change_type());
      match self.change_type() {
        ContractChangeType::PutRequest => {
          if let Some(x) = self.change_as_put_request() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::PutSuccess => {
          if let Some(x) = self.change_as_put_success() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::PutFailure => {
          if let Some(x) = self.change_as_put_failure() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::BroadcastEmitted => {
          if let Some(x) = self.change_as_broadcast_emitted() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::BroadcastReceived => {
          if let Some(x) = self.change_as_broadcast_received() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::UpdateRequest => {
          if let Some(x) = self.change_as_update_request() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::UpdateSuccess => {
          if let Some(x) = self.change_as_update_success() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::UpdateFailure => {
          if let Some(x) = self.change_as_update_failure() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::GetContract => {
          if let Some(x) = self.change_as_get_contract() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContractChangeType::SubscribedToContract => {
          if let Some(x) = self.change_as_subscribed_to_contract() {
            ds.field("change", &x)
          } else {
            ds.field("change", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("change", &x)
        },
      };
      ds.finish()
  }
}
}  // pub mod topology

